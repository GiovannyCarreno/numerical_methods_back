import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/d3-selection/src/namespaces.js
var xhtml, namespaces_default;
var init_namespaces = __esm({
  "node_modules/d3-selection/src/namespaces.js"() {
    xhtml = "http://www.w3.org/1999/xhtml";
    namespaces_default = {
      svg: "http://www.w3.org/2000/svg",
      xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
  }
});

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}
var init_namespace = __esm({
  "node_modules/d3-selection/src/namespace.js"() {
    init_namespaces();
  }
});

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
var init_creator = __esm({
  "node_modules/d3-selection/src/creator.js"() {
    init_namespace();
    init_namespaces();
  }
});

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}
var init_selector = __esm({
  "node_modules/d3-selection/src/selector.js"() {
  }
});

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
var init_select = __esm({
  "node_modules/d3-selection/src/selection/select.js"() {
    init_selection();
    init_selector();
  }
});

// node_modules/d3-selection/src/array.js
function array(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
var init_array = __esm({
  "node_modules/d3-selection/src/array.js"() {
  }
});

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}
var init_selectorAll = __esm({
  "node_modules/d3-selection/src/selectorAll.js"() {
  }
});

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}
var init_selectAll = __esm({
  "node_modules/d3-selection/src/selection/selectAll.js"() {
    init_selection();
    init_array();
    init_selectorAll();
  }
});

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}
var init_matcher = __esm({
  "node_modules/d3-selection/src/matcher.js"() {
  }
});

// node_modules/d3-selection/src/selection/selectChild.js
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var find;
var init_selectChild = __esm({
  "node_modules/d3-selection/src/selection/selectChild.js"() {
    init_matcher();
    find = Array.prototype.find;
  }
});

// node_modules/d3-selection/src/selection/selectChildren.js
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
var filter;
var init_selectChildren = __esm({
  "node_modules/d3-selection/src/selection/selectChildren.js"() {
    init_matcher();
    filter = Array.prototype.filter;
  }
});

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
var init_filter = __esm({
  "node_modules/d3-selection/src/selection/filter.js"() {
    init_selection();
    init_matcher();
  }
});

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}
var init_sparse = __esm({
  "node_modules/d3-selection/src/selection/sparse.js"() {
  }
});

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
var init_enter = __esm({
  "node_modules/d3-selection/src/selection/enter.js"() {
    init_sparse();
    init_selection();
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function(child, next2) {
        return this._parent.insertBefore(child, next2);
      },
      querySelector: function(selector) {
        return this._parent.querySelector(selector);
      },
      querySelectorAll: function(selector) {
        return this._parent.querySelectorAll(selector);
      }
    };
  }
});

// node_modules/d3-selection/src/constant.js
function constant_default(x2) {
  return function() {
    return x2;
  };
}
var init_constant = __esm({
  "node_modules/d3-selection/src/constant.js"() {
  }
});

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function") value = constant_default(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next2 = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next2 || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
var init_data = __esm({
  "node_modules/d3-selection/src/selection/data.js"() {
    init_selection();
    init_enter();
    init_constant();
  }
});

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}
var init_exit = __esm({
  "node_modules/d3-selection/src/selection/exit.js"() {
    init_sparse();
    init_selection();
  }
});

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
var init_join = __esm({
  "node_modules/d3-selection/src/selection/join.js"() {
  }
});

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}
var init_merge = __esm({
  "node_modules/d3-selection/src/selection/merge.js"() {
    init_selection();
  }
});

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next2 = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next2 && node.compareDocumentPosition(next2) ^ 4) next2.parentNode.insertBefore(node, next2);
        next2 = node;
      }
    }
  }
  return this;
}
var init_order = __esm({
  "node_modules/d3-selection/src/selection/order.js"() {
  }
});

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare) compare = ascending;
  function compareNode(a2, b) {
    return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
var init_sort = __esm({
  "node_modules/d3-selection/src/selection/sort.js"() {
    init_selection();
  }
});

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
var init_call = __esm({
  "node_modules/d3-selection/src/selection/call.js"() {
  }
});

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}
var init_nodes = __esm({
  "node_modules/d3-selection/src/selection/nodes.js"() {
  }
});

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}
var init_node = __esm({
  "node_modules/d3-selection/src/selection/node.js"() {
  }
});

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this) ++size;
  return size;
}
var init_size = __esm({
  "node_modules/d3-selection/src/selection/size.js"() {
  }
});

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}
var init_empty = __esm({
  "node_modules/d3-selection/src/selection/empty.js"() {
  }
});

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}
var init_each = __esm({
  "node_modules/d3-selection/src/selection/each.js"() {
  }
});

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}
var init_attr = __esm({
  "node_modules/d3-selection/src/selection/attr.js"() {
    init_namespace();
  }
});

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
var init_window = __esm({
  "node_modules/d3-selection/src/window.js"() {
  }
});

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}
var init_style = __esm({
  "node_modules/d3-selection/src/selection/style.js"() {
    init_window();
  }
});

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
var init_property = __esm({
  "node_modules/d3-selection/src/selection/property.js"() {
  }
});

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
var init_classed = __esm({
  "node_modules/d3-selection/src/selection/classed.js"() {
    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };
  }
});

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}
var init_text = __esm({
  "node_modules/d3-selection/src/selection/text.js"() {
  }
});

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
var init_html = __esm({
  "node_modules/d3-selection/src/selection/html.js"() {
  }
});

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}
var init_raise = __esm({
  "node_modules/d3-selection/src/selection/raise.js"() {
  }
});

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}
var init_lower = __esm({
  "node_modules/d3-selection/src/selection/lower.js"() {
  }
});

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}
var init_append = __esm({
  "node_modules/d3-selection/src/selection/append.js"() {
    init_creator();
  }
});

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}
var init_insert = __esm({
  "node_modules/d3-selection/src/selection/insert.js"() {
    init_creator();
    init_selector();
  }
});

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}
var init_remove = __esm({
  "node_modules/d3-selection/src/selection/remove.js"() {
  }
});

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
var init_clone = __esm({
  "node_modules/d3-selection/src/selection/clone.js"() {
  }
});

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
var init_datum = __esm({
  "node_modules/d3-selection/src/selection/datum.js"() {
  }
});

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on) this.__on = [o];
    else on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}
var init_on = __esm({
  "node_modules/d3-selection/src/selection/on.js"() {
  }
});

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function dispatch_default(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}
var init_dispatch = __esm({
  "node_modules/d3-selection/src/selection/dispatch.js"() {
    init_window();
  }
});

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}
var init_iterator = __esm({
  "node_modules/d3-selection/src/selection/iterator.js"() {
  }
});

// node_modules/d3-selection/src/selection/index.js
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
var root, selection_default;
var init_selection = __esm({
  "node_modules/d3-selection/src/selection/index.js"() {
    init_select();
    init_selectAll();
    init_selectChild();
    init_selectChildren();
    init_filter();
    init_data();
    init_enter();
    init_exit();
    init_join();
    init_merge();
    init_order();
    init_sort();
    init_call();
    init_nodes();
    init_node();
    init_size();
    init_empty();
    init_each();
    init_attr();
    init_style();
    init_property();
    init_classed();
    init_text();
    init_html();
    init_raise();
    init_lower();
    init_append();
    init_insert();
    init_remove();
    init_clone();
    init_datum();
    init_on();
    init_dispatch();
    init_iterator();
    root = [null];
    Selection.prototype = selection.prototype = {
      constructor: Selection,
      select: select_default,
      selectAll: selectAll_default,
      selectChild: selectChild_default,
      selectChildren: selectChildren_default,
      filter: filter_default,
      data: data_default,
      enter: enter_default,
      exit: exit_default,
      join: join_default,
      merge: merge_default,
      selection: selection_selection,
      order: order_default,
      sort: sort_default,
      call: call_default,
      nodes: nodes_default,
      node: node_default,
      size: size_default,
      empty: empty_default,
      each: each_default,
      attr: attr_default,
      style: style_default,
      property: property_default,
      classed: classed_default,
      text: text_default,
      html: html_default,
      raise: raise_default,
      lower: lower_default,
      append: append_default,
      insert: insert_default,
      remove: remove_default,
      clone: clone_default,
      datum: datum_default,
      on: on_default,
      dispatch: dispatch_default,
      [Symbol.iterator]: iterator_default
    };
    selection_default = selection;
  }
});

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}
var init_select2 = __esm({
  "node_modules/d3-selection/src/select.js"() {
    init_selection();
  }
});

// node_modules/d3-selection/src/create.js
function create_default(name) {
  return select_default2(creator_default(name).call(document.documentElement));
}
var init_create = __esm({
  "node_modules/d3-selection/src/create.js"() {
    init_creator();
    init_select2();
  }
});

// node_modules/d3-selection/src/local.js
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
var nextId;
var init_local = __esm({
  "node_modules/d3-selection/src/local.js"() {
    nextId = 0;
    Local.prototype = local.prototype = {
      constructor: Local,
      get: function(node) {
        var id = this._;
        while (!(id in node)) if (!(node = node.parentNode)) return;
        return node[id];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };
  }
});

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}
var init_sourceEvent = __esm({
  "node_modules/d3-selection/src/sourceEvent.js"() {
  }
});

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point5 = svg.createSVGPoint();
      point5.x = event.clientX, point5.y = event.clientY;
      point5 = point5.matrixTransform(node.getScreenCTM().inverse());
      return [point5.x, point5.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
var init_pointer = __esm({
  "node_modules/d3-selection/src/pointer.js"() {
    init_sourceEvent();
  }
});

// node_modules/d3-selection/src/pointers.js
function pointers_default(events, node) {
  if (events.target) {
    events = sourceEvent_default(events);
    if (node === void 0) node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, (event) => pointer_default(event, node));
}
var init_pointers = __esm({
  "node_modules/d3-selection/src/pointers.js"() {
    init_pointer();
    init_sourceEvent();
  }
});

// node_modules/d3-selection/src/selectAll.js
function selectAll_default2(selector) {
  return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array(selector)], root);
}
var init_selectAll2 = __esm({
  "node_modules/d3-selection/src/selectAll.js"() {
    init_array();
    init_selection();
  }
});

// node_modules/d3-selection/src/index.js
var src_exports = {};
__export(src_exports, {
  create: () => create_default,
  creator: () => creator_default,
  local: () => local,
  matcher: () => matcher_default,
  namespace: () => namespace_default,
  namespaces: () => namespaces_default,
  pointer: () => pointer_default,
  pointers: () => pointers_default,
  select: () => select_default2,
  selectAll: () => selectAll_default2,
  selection: () => selection_default,
  selector: () => selector_default,
  selectorAll: () => selectorAll_default,
  style: () => styleValue,
  window: () => window_default
});
var init_src = __esm({
  "node_modules/d3-selection/src/index.js"() {
    init_create();
    init_creator();
    init_local();
    init_matcher();
    init_namespace();
    init_namespaces();
    init_pointer();
    init_pointers();
    init_select2();
    init_selectAll2();
    init_selection();
    init_selector();
    init_selectorAll();
    init_style();
    init_window();
  }
});

// node_modules/d3-shape/src/constant.js
function constant_default2(x2) {
  return function constant() {
    return x2;
  };
}
var init_constant2 = __esm({
  "node_modules/d3-shape/src/constant.js"() {
  }
});

// node_modules/d3-shape/src/math.js
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
}
function asin(x2) {
  return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
}
var abs, atan2, cos, max, min, sin, sqrt, epsilon, pi, halfPi, tau;
var init_math = __esm({
  "node_modules/d3-shape/src/math.js"() {
    abs = Math.abs;
    atan2 = Math.atan2;
    cos = Math.cos;
    max = Math.max;
    min = Math.min;
    sin = Math.sin;
    sqrt = Math.sqrt;
    epsilon = 1e-12;
    pi = Math.PI;
    halfPi = pi / 2;
    tau = 2 * pi;
  }
});

// node_modules/d3-path/src/path.js
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k2 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
function path() {
  return new Path();
}
var pi2, tau2, epsilon2, tauEpsilon, Path;
var init_path = __esm({
  "node_modules/d3-path/src/path.js"() {
    pi2 = Math.PI;
    tau2 = 2 * pi2;
    epsilon2 = 1e-6;
    tauEpsilon = tau2 - epsilon2;
    Path = class {
      constructor(digits) {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null;
        this._ = "";
        this._append = digits == null ? append : appendRound(digits);
      }
      moveTo(x2, y2) {
        this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._append`Z`;
        }
      }
      lineTo(x2, y2) {
        this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
      }
      quadraticCurveTo(x1, y1, x2, y2) {
        this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
      }
      bezierCurveTo(x1, y1, x2, y2, x3, y3) {
        this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
      }
      arcTo(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        if (r < 0) throw new Error(`negative radius: ${r}`);
        let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
        if (this._x1 === null) {
          this._append`M${this._x1 = x1},${this._y1 = y1}`;
        } else if (!(l01_2 > epsilon2)) ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
          this._append`L${this._x1 = x1},${this._y1 = y1}`;
        } else {
          let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
          if (Math.abs(t01 - 1) > epsilon2) {
            this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
          }
          this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
        }
      }
      arc(x2, y2, r, a0, a1, ccw) {
        x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
        if (r < 0) throw new Error(`negative radius: ${r}`);
        let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (this._x1 === null) {
          this._append`M${x0},${y0}`;
        } else if (Math.abs(this._x1 - x0) > epsilon2 || Math.abs(this._y1 - y0) > epsilon2) {
          this._append`L${x0},${y0}`;
        }
        if (!r) return;
        if (da < 0) da = da % tau2 + tau2;
        if (da > tauEpsilon) {
          this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
        } else if (da > epsilon2) {
          this._append`A${r},${r},0,${+(da >= pi2)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
        }
      }
      rect(x2, y2, w, h) {
        this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
      }
      toString() {
        return this._;
      }
    };
    path.prototype = Path.prototype;
  }
});

// node_modules/d3-path/src/index.js
var init_src2 = __esm({
  "node_modules/d3-path/src/index.js"() {
    init_path();
  }
});

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}
var init_path2 = __esm({
  "node_modules/d3-shape/src/path.js"() {
    init_src2();
  }
});

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default2(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
  function arc() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
    if (!context) context = buffer = path2();
    if (r1 < r0) r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon)) context.moveTo(0, 0);
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da < pi) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min(rc, (r0 - lc) / (kc - 1));
            rc1 = min(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon)) context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t02 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc) context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
          context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
        }
      } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t12 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc) context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw);
          context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
        }
      } else context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a2) * r, sin(a2) * r];
  };
  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default2(+_), arc) : innerRadius;
  };
  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default2(+_), arc) : outerRadius;
  };
  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default2(+_), arc) : cornerRadius;
  };
  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), arc) : padRadius;
  };
  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default2(+_), arc) : startAngle;
  };
  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default2(+_), arc) : endAngle;
  };
  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default2(+_), arc) : padAngle;
  };
  arc.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };
  return arc;
}
var init_arc = __esm({
  "node_modules/d3-shape/src/arc.js"() {
    init_constant2();
    init_math();
    init_path2();
  }
});

// node_modules/d3-shape/src/array.js
function array_default(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
var slice;
var init_array2 = __esm({
  "node_modules/d3-shape/src/array.js"() {
    slice = Array.prototype.slice;
  }
});

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
function linear_default(context) {
  return new Linear(context);
}
var init_linear = __esm({
  "node_modules/d3-shape/src/curve/linear.js"() {
    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
          default:
            this._context.lineTo(x2, y2);
            break;
        }
      }
    };
  }
});

// node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}
var init_point = __esm({
  "node_modules/d3-shape/src/point.js"() {
  }
});

// node_modules/d3-shape/src/line.js
function line_default(x2, y2) {
  var defined = constant_default2(true), context = null, curve = linear_default, output = null, path2 = withPath(line);
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x : constant_default2(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y : constant_default2(y2);
  function line(data) {
    var i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x2(d, i, data), +y2(d, i, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default2(+_), line) : x2;
  };
  line.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default2(+_), line) : y2;
  };
  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default2(!!_), line) : defined;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };
  return line;
}
var init_line = __esm({
  "node_modules/d3-shape/src/line.js"() {
    init_array2();
    init_constant2();
    init_linear();
    init_path2();
    init_point();
  }
});

// node_modules/d3-shape/src/area.js
function area_default(x0, y0, y1) {
  var x1 = null, defined = constant_default2(true), context = null, curve = linear_default, output = null, path2 = withPath(area);
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant_default2(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant_default2(0) : constant_default2(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant_default2(+y1);
  function area(data) {
    var i, j, k2, n = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null) output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined).curve(curve).context(context);
  }
  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default2(+_), x1 = null, area) : x0;
  };
  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default2(+_), area) : x0;
  };
  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), area) : x1;
  };
  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default2(+_), y1 = null, area) : y0;
  };
  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default2(+_), area) : y0;
  };
  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default2(!!_), area) : defined;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };
  return area;
}
var init_area = __esm({
  "node_modules/d3-shape/src/area.js"() {
    init_array2();
    init_constant2();
    init_linear();
    init_line();
    init_path2();
    init_point();
  }
});

// node_modules/d3-shape/src/descending.js
function descending_default(a2, b) {
  return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
var init_descending = __esm({
  "node_modules/d3-shape/src/descending.js"() {
  }
});

// node_modules/d3-shape/src/identity.js
function identity_default(d) {
  return d;
}
var init_identity = __esm({
  "node_modules/d3-shape/src/identity.js"() {
  }
});

// node_modules/d3-shape/src/pie.js
function pie_default() {
  var value = identity_default, sortValues = descending_default, sort = null, startAngle = constant_default2(0), endAngle = constant_default2(tau), padAngle = constant_default2(0);
  function pie(data) {
    var i, n = (data = array_default(data)).length, j, k2, sum2 = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum2 += v;
      }
    }
    if (sortValues != null) index.sort(function(i2, j2) {
      return sortValues(arcs[i2], arcs[j2]);
    });
    else if (sort != null) index.sort(function(i2, j2) {
      return sort(data[i2], data[j2]);
    });
    for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default2(+_), pie) : value;
  };
  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };
  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };
  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default2(+_), pie) : startAngle;
  };
  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default2(+_), pie) : endAngle;
  };
  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default2(+_), pie) : padAngle;
  };
  return pie;
}
var init_pie = __esm({
  "node_modules/d3-shape/src/pie.js"() {
    init_array2();
    init_constant2();
    init_descending();
    init_identity();
    init_math();
  }
});

// node_modules/d3-shape/src/curve/radial.js
function Radial(curve) {
  this._curve = curve;
}
function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }
  radial._curve = curve;
  return radial;
}
var curveRadialLinear;
var init_radial = __esm({
  "node_modules/d3-shape/src/curve/radial.js"() {
    init_linear();
    curveRadialLinear = curveRadial(linear_default);
    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a2, r) {
        this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
      }
    };
  }
});

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l) {
  var c2 = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_) {
    return arguments.length ? c2(curveRadial(_)) : c2()._curve;
  };
  return l;
}
function lineRadial_default() {
  return lineRadial(line_default().curve(curveRadialLinear));
}
var init_lineRadial = __esm({
  "node_modules/d3-shape/src/lineRadial.js"() {
    init_radial();
    init_line();
  }
});

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a2 = area_default().curve(curveRadialLinear), c2 = a2.curve, x0 = a2.lineX0, x1 = a2.lineX1, y0 = a2.lineY0, y1 = a2.lineY1;
  a2.angle = a2.x, delete a2.x;
  a2.startAngle = a2.x0, delete a2.x0;
  a2.endAngle = a2.x1, delete a2.x1;
  a2.radius = a2.y, delete a2.y;
  a2.innerRadius = a2.y0, delete a2.y0;
  a2.outerRadius = a2.y1, delete a2.y1;
  a2.lineStartAngle = function() {
    return lineRadial(x0());
  }, delete a2.lineX0;
  a2.lineEndAngle = function() {
    return lineRadial(x1());
  }, delete a2.lineX1;
  a2.lineInnerRadius = function() {
    return lineRadial(y0());
  }, delete a2.lineY0;
  a2.lineOuterRadius = function() {
    return lineRadial(y1());
  }, delete a2.lineY1;
  a2.curve = function(_) {
    return arguments.length ? c2(curveRadial(_)) : c2()._curve;
  };
  return a2;
}
var init_areaRadial = __esm({
  "node_modules/d3-shape/src/areaRadial.js"() {
    init_radial();
    init_area();
    init_lineRadial();
  }
});

// node_modules/d3-shape/src/pointRadial.js
function pointRadial_default(x2, y2) {
  return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
}
var init_pointRadial = __esm({
  "node_modules/d3-shape/src/pointRadial.js"() {
  }
});

// node_modules/d3-shape/src/curve/bump.js
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}
function bumpRadial(context) {
  return new BumpRadial(context);
}
var Bump, BumpRadial;
var init_bump = __esm({
  "node_modules/d3-shape/src/curve/bump.js"() {
    init_pointRadial();
    Bump = class {
      constructor(context, x2) {
        this._context = context;
        this._x = x2;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line) this._context.lineTo(x2, y2);
            else this._context.moveTo(x2, y2);
            break;
          }
          case 1:
            this._point = 2;
          default: {
            if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
            else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
            break;
          }
        }
        this._x0 = x2, this._y0 = y2;
      }
    };
    BumpRadial = class {
      constructor(context) {
        this._context = context;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
      }
      point(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point === 0) {
          this._point = 1;
        } else {
          const p0 = pointRadial_default(this._x0, this._y0);
          const p1 = pointRadial_default(this._x0, this._y0 = (this._y0 + y2) / 2);
          const p2 = pointRadial_default(x2, this._y0);
          const p3 = pointRadial_default(x2, y2);
          this._context.moveTo(...p0);
          this._context.bezierCurveTo(...p1, ...p2, ...p3);
        }
        this._x0 = x2, this._y0 = y2;
      }
    };
  }
});

// node_modules/d3-shape/src/link.js
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link(curve) {
  let source = linkSource, target = linkTarget, x2 = x, y2 = y, context = null, output = null, path2 = withPath(link2);
  function link2() {
    let buffer;
    const argv = slice.call(arguments);
    const s2 = source.apply(this, argv);
    const t = target.apply(this, argv);
    if (context == null) output = curve(buffer = path2());
    output.lineStart();
    argv[0] = s2, output.point(+x2.apply(this, argv), +y2.apply(this, argv));
    argv[0] = t, output.point(+x2.apply(this, argv), +y2.apply(this, argv));
    output.lineEnd();
    if (buffer) return output = null, buffer + "" || null;
  }
  link2.source = function(_) {
    return arguments.length ? (source = _, link2) : source;
  };
  link2.target = function(_) {
    return arguments.length ? (target = _, link2) : target;
  };
  link2.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default2(+_), link2) : x2;
  };
  link2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default2(+_), link2) : y2;
  };
  link2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link2) : context;
  };
  return link2;
}
function linkHorizontal() {
  return link(bumpX);
}
function linkVertical() {
  return link(bumpY);
}
function linkRadial() {
  const l = link(bumpRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}
var init_link = __esm({
  "node_modules/d3-shape/src/link.js"() {
    init_array2();
    init_constant2();
    init_bump();
    init_path2();
    init_point();
  }
});

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3, asterisk_default;
var init_asterisk = __esm({
  "node_modules/d3-shape/src/symbol/asterisk.js"() {
    init_math();
    sqrt3 = sqrt(3);
    asterisk_default = {
      draw(context, size) {
        const r = sqrt(size + min(size / 28, 0.75)) * 0.59436;
        const t = r / 2;
        const u = t * sqrt3;
        context.moveTo(0, r);
        context.lineTo(0, -r);
        context.moveTo(-u, -t);
        context.lineTo(u, t);
        context.moveTo(-u, t);
        context.lineTo(u, -t);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/circle.js
var circle_default;
var init_circle = __esm({
  "node_modules/d3-shape/src/symbol/circle.js"() {
    init_math();
    circle_default = {
      draw(context, size) {
        const r = sqrt(size / pi);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/cross.js
var cross_default;
var init_cross = __esm({
  "node_modules/d3-shape/src/symbol/cross.js"() {
    init_math();
    cross_default = {
      draw(context, size) {
        const r = sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/diamond.js
var tan30, tan30_2, diamond_default;
var init_diamond = __esm({
  "node_modules/d3-shape/src/symbol/diamond.js"() {
    init_math();
    tan30 = sqrt(1 / 3);
    tan30_2 = tan30 * 2;
    diamond_default = {
      draw(context, size) {
        const y2 = sqrt(size / tan30_2);
        const x2 = y2 * tan30;
        context.moveTo(0, -y2);
        context.lineTo(x2, 0);
        context.lineTo(0, y2);
        context.lineTo(-x2, 0);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/diamond2.js
var diamond2_default;
var init_diamond2 = __esm({
  "node_modules/d3-shape/src/symbol/diamond2.js"() {
    init_math();
    diamond2_default = {
      draw(context, size) {
        const r = sqrt(size) * 0.62625;
        context.moveTo(0, -r);
        context.lineTo(r, 0);
        context.lineTo(0, r);
        context.lineTo(-r, 0);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/plus.js
var plus_default;
var init_plus = __esm({
  "node_modules/d3-shape/src/symbol/plus.js"() {
    init_math();
    plus_default = {
      draw(context, size) {
        const r = sqrt(size - min(size / 7, 2)) * 0.87559;
        context.moveTo(-r, 0);
        context.lineTo(r, 0);
        context.moveTo(0, r);
        context.lineTo(0, -r);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/square.js
var square_default;
var init_square = __esm({
  "node_modules/d3-shape/src/symbol/square.js"() {
    init_math();
    square_default = {
      draw(context, size) {
        const w = sqrt(size);
        const x2 = -w / 2;
        context.rect(x2, x2, w, w);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/square2.js
var square2_default;
var init_square2 = __esm({
  "node_modules/d3-shape/src/symbol/square2.js"() {
    init_math();
    square2_default = {
      draw(context, size) {
        const r = sqrt(size) * 0.4431;
        context.moveTo(r, r);
        context.lineTo(r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, r);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/star.js
var ka, kr, kx, ky, star_default;
var init_star = __esm({
  "node_modules/d3-shape/src/symbol/star.js"() {
    init_math();
    ka = 0.8908130915292852;
    kr = sin(pi / 10) / sin(7 * pi / 10);
    kx = sin(tau / 10) * kr;
    ky = -cos(tau / 10) * kr;
    star_default = {
      draw(context, size) {
        const r = sqrt(size * ka);
        const x2 = kx * r;
        const y2 = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x2, y2);
        for (let i = 1; i < 5; ++i) {
          const a2 = tau * i / 5;
          const c2 = cos(a2);
          const s2 = sin(a2);
          context.lineTo(s2 * r, -c2 * r);
          context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
        }
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32, triangle_default;
var init_triangle = __esm({
  "node_modules/d3-shape/src/symbol/triangle.js"() {
    init_math();
    sqrt32 = sqrt(3);
    triangle_default = {
      draw(context, size) {
        const y2 = -sqrt(size / (sqrt32 * 3));
        context.moveTo(0, y2 * 2);
        context.lineTo(-sqrt32 * y2, -y2);
        context.lineTo(sqrt32 * y2, -y2);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33, triangle2_default;
var init_triangle2 = __esm({
  "node_modules/d3-shape/src/symbol/triangle2.js"() {
    init_math();
    sqrt33 = sqrt(3);
    triangle2_default = {
      draw(context, size) {
        const s2 = sqrt(size) * 0.6824;
        const t = s2 / 2;
        const u = s2 * sqrt33 / 2;
        context.moveTo(0, -s2);
        context.lineTo(u, t);
        context.lineTo(-u, t);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/wye.js
var c, s, k, a, wye_default;
var init_wye = __esm({
  "node_modules/d3-shape/src/symbol/wye.js"() {
    init_math();
    c = -0.5;
    s = sqrt(3) / 2;
    k = 1 / sqrt(12);
    a = (k / 2 + 1) * 3;
    wye_default = {
      draw(context, size) {
        const r = sqrt(size / a);
        const x0 = r / 2, y0 = r * k;
        const x1 = x0, y1 = r * k + r;
        const x2 = -x1, y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/times.js
var times_default;
var init_times = __esm({
  "node_modules/d3-shape/src/symbol/times.js"() {
    init_math();
    times_default = {
      draw(context, size) {
        const r = sqrt(size - min(size / 6, 1.7)) * 0.6189;
        context.moveTo(-r, -r);
        context.lineTo(r, r);
        context.moveTo(-r, r);
        context.lineTo(r, -r);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol.js
function Symbol2(type, size) {
  let context = null, path2 = withPath(symbol);
  type = typeof type === "function" ? type : constant_default2(type || circle_default);
  size = typeof size === "function" ? size : constant_default2(size === void 0 ? 64 : +size);
  function symbol() {
    let buffer;
    if (!context) context = buffer = path2();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }
  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant_default2(_), symbol) : type;
  };
  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default2(+_), symbol) : size;
  };
  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };
  return symbol;
}
var symbolsFill, symbolsStroke;
var init_symbol = __esm({
  "node_modules/d3-shape/src/symbol.js"() {
    init_constant2();
    init_path2();
    init_asterisk();
    init_circle();
    init_cross();
    init_diamond();
    init_diamond2();
    init_plus();
    init_square();
    init_square2();
    init_star();
    init_triangle();
    init_triangle2();
    init_wye();
    init_times();
    symbolsFill = [
      circle_default,
      cross_default,
      diamond_default,
      square_default,
      star_default,
      triangle_default,
      wye_default
    ];
    symbolsStroke = [
      circle_default,
      plus_default,
      times_default,
      triangle2_default,
      asterisk_default,
      square2_default,
      diamond2_default
    ];
  }
});

// node_modules/d3-shape/src/noop.js
function noop_default() {
}
var init_noop = __esm({
  "node_modules/d3-shape/src/noop.js"() {
  }
});

// node_modules/d3-shape/src/curve/basis.js
function point(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
function basis_default(context) {
  return new Basis(context);
}
var init_basis = __esm({
  "node_modules/d3-shape/src/curve/basis.js"() {
    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3:
            point(this, this._x1, this._y1);
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
          default:
            point(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
function basisClosed_default(context) {
  return new BasisClosed(context);
}
var init_basisClosed = __esm({
  "node_modules/d3-shape/src/curve/basisClosed.js"() {
    init_noop();
    init_basis();
    BasisClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x2 = x2, this._y2 = y2;
            break;
          case 1:
            this._point = 2;
            this._x3 = x2, this._y3 = y2;
            break;
          case 2:
            this._point = 3;
            this._x4 = x2, this._y4 = y2;
            this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
            break;
          default:
            point(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
function basisOpen_default(context) {
  return new BasisOpen(context);
}
var init_basisOpen = __esm({
  "node_modules/d3-shape/src/curve/basisOpen.js"() {
    init_basis();
    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
            this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
            break;
          case 3:
            this._point = 4;
          default:
            point(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
var bundle_default;
var init_bundle = __esm({
  "node_modules/d3-shape/src/curve/bundle.js"() {
    init_basis();
    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x2 = this._x, y2 = this._y, j = x2.length - 1;
        if (j > 0) {
          var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }
        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x2, y2) {
        this._x.push(+x2);
        this._y.push(+y2);
      }
    };
    bundle_default = function custom(beta) {
      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }
      bundle.beta = function(beta2) {
        return custom(+beta2);
      };
      return bundle;
    }(0.85);
  }
});

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinal_default;
var init_cardinal = __esm({
  "node_modules/d3-shape/src/curve/cardinal.js"() {
    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            point2(this, this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            this._x1 = x2, this._y1 = y2;
            break;
          case 2:
            this._point = 3;
          default:
            point2(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    cardinal_default = function custom2(tension) {
      function cardinal(context) {
        return new Cardinal(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom2(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinalClosed_default;
var init_cardinalClosed = __esm({
  "node_modules/d3-shape/src/curve/cardinalClosed.js"() {
    init_noop();
    init_cardinal();
    CardinalClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x2, this._y3 = y2;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x2, this._y4 = y2);
            break;
          case 2:
            this._point = 3;
            this._x5 = x2, this._y5 = y2;
            break;
          default:
            point2(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    cardinalClosed_default = function custom3(tension) {
      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom3(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinalOpen_default;
var init_cardinalOpen = __esm({
  "node_modules/d3-shape/src/curve/cardinalOpen.js"() {
    init_cardinal();
    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point2(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    cardinalOpen_default = function custom4(tension) {
      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom4(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRom_default;
var init_catmullRom = __esm({
  "node_modules/d3-shape/src/curve/catmullRom.js"() {
    init_math();
    init_cardinal();
    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            this.point(this._x2, this._y2);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x2, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
          default:
            point3(this, x2, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    catmullRom_default = function custom5(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom5(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRomClosed_default;
var init_catmullRomClosed = __esm({
  "node_modules/d3-shape/src/curve/catmullRomClosed.js"() {
    init_cardinalClosed();
    init_noop();
    init_catmullRom();
    CatmullRomClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x2, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x2, this._y3 = y2;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x2, this._y4 = y2);
            break;
          case 2:
            this._point = 3;
            this._x5 = x2, this._y5 = y2;
            break;
          default:
            point3(this, x2, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    catmullRomClosed_default = function custom6(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom6(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRomOpen_default;
var init_catmullRomOpen = __esm({
  "node_modules/d3-shape/src/curve/catmullRomOpen.js"() {
    init_cardinalOpen();
    init_catmullRom();
    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x2, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point3(this, x2, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    catmullRomOpen_default = function custom7(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom7(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
function linearClosed_default(context) {
  return new LinearClosed(context);
}
var init_linearClosed = __esm({
  "node_modules/d3-shape/src/curve/linearClosed.js"() {
    init_noop();
    LinearClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) this._context.lineTo(x2, y2);
        else this._point = 1, this._context.moveTo(x2, y2);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/monotone.js
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point4(that, t02, t12) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
function ReflectContext(context) {
  this._context = context;
}
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
var init_monotone = __esm({
  "node_modules/d3-shape/src/curve/monotone.js"() {
    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
          case 3:
            point4(this, this._t0, slope2(this, this._t0));
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        var t12 = NaN;
        x2 = +x2, y2 = +y2;
        if (x2 === this._x1 && y2 === this._y1) return;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            point4(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
            break;
          default:
            point4(this, this._t0, t12 = slope3(this, x2, y2));
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
        this._t0 = t12;
      }
    };
    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
      MonotoneX.prototype.point.call(this, y2, x2);
    };
    ReflectContext.prototype = {
      moveTo: function(x2, y2) {
        this._context.moveTo(y2, x2);
      },
      closePath: function() {
        this._context.closePath();
      },
      lineTo: function(x2, y2) {
        this._context.lineTo(y2, x2);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
        this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
function controlPoints(x2) {
  var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i) a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i) m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}
function natural_default(context) {
  return new Natural(context);
}
var init_natural = __esm({
  "node_modules/d3-shape/src/curve/natural.js"() {
    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x2 = this._x, y2 = this._y, n = x2.length;
        if (n) {
          this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
          if (n === 2) {
            this._context.lineTo(x2[1], y2[1]);
          } else {
            var px = controlPoints(x2), py = controlPoints(y2);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
            }
          }
        }
        if (this._line || this._line !== 0 && n === 1) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x2, y2) {
        this._x.push(+x2);
        this._y.push(+y2);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}
var init_step = __esm({
  "node_modules/d3-shape/src/curve/step.js"() {
    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y2);
              this._context.lineTo(x2, y2);
            } else {
              var x1 = this._x * (1 - this._t) + x2 * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y2);
            }
            break;
          }
        }
        this._x = x2, this._y = y2;
      }
    };
  }
});

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}
var init_none = __esm({
  "node_modules/d3-shape/src/offset/none.js"() {
  }
});

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}
var init_none2 = __esm({
  "node_modules/d3-shape/src/order/none.js"() {
  }
});

// node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function stack_default() {
  var keys = constant_default2([]), order = none_default2, offset = none_default, value = stackValue;
  function stack(data) {
    var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
      }
    }
    for (i = 0, oz = array_default(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default2(Array.from(_)), stack) : keys;
  };
  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default2(+_), stack) : value;
  };
  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default2(Array.from(_)), stack) : order;
  };
  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
  };
  return stack;
}
var init_stack = __esm({
  "node_modules/d3-shape/src/stack.js"() {
    init_array2();
    init_constant2();
    init_none();
    init_none2();
  }
});

// node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y2; j < m; ++j) {
    for (y2 = i = 0; i < n; ++i) y2 += series[i][j][1] || 0;
    if (y2) for (i = 0; i < n; ++i) series[i][j][1] /= y2;
  }
  none_default(series, order);
}
var init_expand = __esm({
  "node_modules/d3-shape/src/offset/expand.js"() {
    init_none();
  }
});

// node_modules/d3-shape/src/offset/diverging.js
function diverging_default(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}
var init_diverging = __esm({
  "node_modules/d3-shape/src/offset/diverging.js"() {
  }
});

// node_modules/d3-shape/src/offset/silhouette.js
function silhouette_default(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y2 = 0; i < n; ++i) y2 += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y2 / 2;
  }
  none_default(series, order);
}
var init_silhouette = __esm({
  "node_modules/d3-shape/src/offset/silhouette.js"() {
    init_none();
  }
});

// node_modules/d3-shape/src/offset/wiggle.js
function wiggle_default(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y2 = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i; ++k2) {
        var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    if (s1) y2 -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y2;
  none_default(series, order);
}
var init_wiggle = __esm({
  "node_modules/d3-shape/src/offset/wiggle.js"() {
    init_none();
  }
});

// node_modules/d3-shape/src/order/appearance.js
function appearance_default(series) {
  var peaks = series.map(peak);
  return none_default2(series).sort(function(a2, b) {
    return peaks[a2] - peaks[b];
  });
}
function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}
var init_appearance = __esm({
  "node_modules/d3-shape/src/order/appearance.js"() {
    init_none2();
  }
});

// node_modules/d3-shape/src/order/ascending.js
function ascending_default(series) {
  var sums = series.map(sum);
  return none_default2(series).sort(function(a2, b) {
    return sums[a2] - sums[b];
  });
}
function sum(series) {
  var s2 = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s2 += v;
  return s2;
}
var init_ascending = __esm({
  "node_modules/d3-shape/src/order/ascending.js"() {
    init_none2();
  }
});

// node_modules/d3-shape/src/order/descending.js
function descending_default2(series) {
  return ascending_default(series).reverse();
}
var init_descending2 = __esm({
  "node_modules/d3-shape/src/order/descending.js"() {
    init_ascending();
  }
});

// node_modules/d3-shape/src/order/insideOut.js
function insideOut_default(series) {
  var n = series.length, i, j, sums = series.map(sum), order = appearance_default(series), top = 0, bottom = 0, tops = [], bottoms = [];
  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }
  return bottoms.reverse().concat(tops);
}
var init_insideOut = __esm({
  "node_modules/d3-shape/src/order/insideOut.js"() {
    init_appearance();
    init_ascending();
  }
});

// node_modules/d3-shape/src/order/reverse.js
function reverse_default(series) {
  return none_default2(series).reverse();
}
var init_reverse = __esm({
  "node_modules/d3-shape/src/order/reverse.js"() {
    init_none2();
  }
});

// node_modules/d3-shape/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  arc: () => arc_default,
  area: () => area_default,
  areaRadial: () => areaRadial_default,
  curveBasis: () => basis_default,
  curveBasisClosed: () => basisClosed_default,
  curveBasisOpen: () => basisOpen_default,
  curveBumpX: () => bumpX,
  curveBumpY: () => bumpY,
  curveBundle: () => bundle_default,
  curveCardinal: () => cardinal_default,
  curveCardinalClosed: () => cardinalClosed_default,
  curveCardinalOpen: () => cardinalOpen_default,
  curveCatmullRom: () => catmullRom_default,
  curveCatmullRomClosed: () => catmullRomClosed_default,
  curveCatmullRomOpen: () => catmullRomOpen_default,
  curveLinear: () => linear_default,
  curveLinearClosed: () => linearClosed_default,
  curveMonotoneX: () => monotoneX,
  curveMonotoneY: () => monotoneY,
  curveNatural: () => natural_default,
  curveStep: () => step_default,
  curveStepAfter: () => stepAfter,
  curveStepBefore: () => stepBefore,
  line: () => line_default,
  lineRadial: () => lineRadial_default,
  link: () => link,
  linkHorizontal: () => linkHorizontal,
  linkRadial: () => linkRadial,
  linkVertical: () => linkVertical,
  pie: () => pie_default,
  pointRadial: () => pointRadial_default,
  radialArea: () => areaRadial_default,
  radialLine: () => lineRadial_default,
  stack: () => stack_default,
  stackOffsetDiverging: () => diverging_default,
  stackOffsetExpand: () => expand_default,
  stackOffsetNone: () => none_default,
  stackOffsetSilhouette: () => silhouette_default,
  stackOffsetWiggle: () => wiggle_default,
  stackOrderAppearance: () => appearance_default,
  stackOrderAscending: () => ascending_default,
  stackOrderDescending: () => descending_default2,
  stackOrderInsideOut: () => insideOut_default,
  stackOrderNone: () => none_default2,
  stackOrderReverse: () => reverse_default,
  symbol: () => Symbol2,
  symbolAsterisk: () => asterisk_default,
  symbolCircle: () => circle_default,
  symbolCross: () => cross_default,
  symbolDiamond: () => diamond_default,
  symbolDiamond2: () => diamond2_default,
  symbolPlus: () => plus_default,
  symbolSquare: () => square_default,
  symbolSquare2: () => square2_default,
  symbolStar: () => star_default,
  symbolTimes: () => times_default,
  symbolTriangle: () => triangle_default,
  symbolTriangle2: () => triangle2_default,
  symbolWye: () => wye_default,
  symbolX: () => times_default,
  symbols: () => symbolsFill,
  symbolsFill: () => symbolsFill,
  symbolsStroke: () => symbolsStroke
});
var init_src3 = __esm({
  "node_modules/d3-shape/src/index.js"() {
    init_arc();
    init_area();
    init_line();
    init_pie();
    init_areaRadial();
    init_lineRadial();
    init_pointRadial();
    init_link();
    init_symbol();
    init_asterisk();
    init_circle();
    init_cross();
    init_diamond();
    init_diamond2();
    init_plus();
    init_square();
    init_square2();
    init_star();
    init_triangle();
    init_triangle2();
    init_wye();
    init_times();
    init_basisClosed();
    init_basisOpen();
    init_basis();
    init_bump();
    init_bundle();
    init_cardinalClosed();
    init_cardinalOpen();
    init_cardinal();
    init_catmullRomClosed();
    init_catmullRomOpen();
    init_catmullRom();
    init_linearClosed();
    init_linear();
    init_monotone();
    init_natural();
    init_step();
    init_stack();
    init_expand();
    init_diverging();
    init_none();
    init_silhouette();
    init_wiggle();
    init_appearance();
    init_ascending();
    init_descending2();
    init_insideOut();
    init_none2();
    init_reverse();
  }
});

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
var init_define = __esm({
  "node_modules/d3-color/src/define.js"() {
  }
});

// node_modules/d3-color/src/color.js
function Color() {
}
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a2) {
  if (a2 <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a2) {
  if (a2 <= 0) h = s2 = l = NaN;
  else if (l <= 0 || l >= 1) h = s2 = NaN;
  else if (s2 <= 0) h = NaN;
  return new Hsl(h, s2, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max3 = Math.max(r, g, b), h = NaN, s2 = max3 - min3, l = (max3 + min3) / 2;
  if (s2) {
    if (r === max3) h = (g - b) / s2 + (g < b) * 6;
    else if (g === max3) h = (b - r) / s2 + 2;
    else h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max3 + min3 : 2 - max3 - min3;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
var darker, brighter, reI, reN, reP, reHex, reRgbInteger, reRgbPercent, reRgbaInteger, reRgbaPercent, reHslPercent, reHslaPercent, named;
var init_color = __esm({
  "node_modules/d3-color/src/color.js"() {
    init_define();
    darker = 0.7;
    brighter = 1 / darker;
    reI = "\\s*([+-]?\\d+)\\s*";
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
    reHex = /^#([0-9a-f]{3,8})$/;
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
    named = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define_default(Color, color, {
      copy(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    define_default(Rgb, rgb, extend(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    define_default(Hsl, hsl, extend(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a2 = clampa(this.opacity);
        return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
      }
    }));
  }
});

// node_modules/d3-color/src/math.js
var radians, degrees;
var init_math2 = __esm({
  "node_modules/d3-color/src/math.js"() {
    radians = Math.PI / 180;
    degrees = 180 / Math.PI;
  }
});

// node_modules/d3-color/src/lab.js
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
  if (r === g && g === b) x2 = z = y2;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}
function lab(l, a2, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b, opacity == null ? 1 : opacity);
}
function Lab(l, a2, b, opacity) {
  this.l = +l;
  this.a = +a2;
  this.b = +b;
  this.opacity = +opacity;
}
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function lch(l, c2, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
}
function hcl(h, c2, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c2, l, opacity) {
  this.h = +h;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
var K, Xn, Yn, Zn, t0, t1, t2, t3;
var init_lab = __esm({
  "node_modules/d3-color/src/lab.js"() {
    init_define();
    init_color();
    init_math2();
    K = 18;
    Xn = 0.96422;
    Yn = 1;
    Zn = 0.82521;
    t0 = 4 / 29;
    t1 = 6 / 29;
    t2 = 3 * t1 * t1;
    t3 = t1 * t1 * t1;
    define_default(Lab, lab, extend(Color, {
      brighter(k2) {
        return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
      },
      darker(k2) {
        return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
      },
      rgb() {
        var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
        x2 = Xn * lab2xyz(x2);
        y2 = Yn * lab2xyz(y2);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
          lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
          this.opacity
        );
      }
    }));
    define_default(Hcl, hcl, extend(Color, {
      brighter(k2) {
        return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
      },
      darker(k2) {
        return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
      },
      rgb() {
        return hcl2lab(this).rgb();
      }
    }));
  }
});

// node_modules/d3-color/src/cubehelix.js
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
}
function cubehelix(h, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
var A, B, C, D, E, ED, EB, BC_DA;
var init_cubehelix = __esm({
  "node_modules/d3-color/src/cubehelix.js"() {
    init_define();
    init_color();
    init_math2();
    A = -0.14861;
    B = 1.78277;
    C = -0.29227;
    D = -0.90649;
    E = 1.97294;
    ED = E * D;
    EB = E * B;
    BC_DA = B * C - D * A;
    define_default(Cubehelix, cubehelix, extend(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
      },
      rgb() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
        return new Rgb(
          255 * (l + a2 * (A * cosh2 + B * sinh2)),
          255 * (l + a2 * (C * cosh2 + D * sinh2)),
          255 * (l + a2 * (E * cosh2)),
          this.opacity
        );
      }
    }));
  }
});

// node_modules/d3-color/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  color: () => color,
  cubehelix: () => cubehelix,
  gray: () => gray,
  hcl: () => hcl,
  hsl: () => hsl,
  lab: () => lab,
  lch: () => lch,
  rgb: () => rgb
});
var init_src4 = __esm({
  "node_modules/d3-color/src/index.js"() {
    init_color();
    init_lab();
    init_cubehelix();
  }
});

// node_modules/function-plot/dist/globals.js
var require_globals = __commonJS({
  "node_modules/function-plot/dist/globals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.registerGraphType = void 0;
    var d3_color_1 = (init_src4(), __toCommonJS(src_exports3));
    var Globals = {
      COLORS: [
        "steelblue",
        "red",
        "#05b378",
        "orange",
        "#4040e8",
        "yellow",
        "brown",
        "magenta",
        "cyan"
      ].map(function(v) {
        return (0, d3_color_1.hsl)(v);
      }),
      DEFAULT_WIDTH: 550,
      DEFAULT_HEIGHT: 350,
      DEFAULT_ITERATIONS: null,
      TIP_X_EPS: 1,
      MAX_ITERATIONS: 0,
      graphTypes: {}
    };
    Globals.MAX_ITERATIONS = Globals.DEFAULT_WIDTH * 10;
    function registerGraphType(graphType, graphTypeBulder) {
      if (Object.hasOwn(Globals.graphTypes, graphType)) {
        throw new Error(`registerGraphType: graphType ${graphType} is already registered.`);
      }
      Globals.graphTypes[graphType] = graphTypeBulder;
    }
    exports.registerGraphType = registerGraphType;
    exports.default = Globals;
  }
});

// node_modules/function-plot/dist/utils.js
var require_utils = __commonJS({
  "node_modules/function-plot/dist/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals_1 = __importDefault(require_globals());
    var utils = {
      linspace: function(lo, hi, n) {
        const step = (hi - lo) / (n - 1);
        return Array.from({ length: n }, (_, i) => lo + step * i);
      },
      logspace: function(lo, hi, n) {
        return this.linspace(lo, hi, n).map((x2) => Math.pow(10, x2));
      },
      isValidNumber: function(v) {
        return typeof v === "number" && !isNaN(v);
      },
      space: function(axis, range, n) {
        const lo = range[0];
        const hi = range[1];
        if (axis.type === "log") {
          return this.logspace(Math.log10(lo), Math.log10(hi), n);
        }
        return this.linspace(lo, hi, n);
      },
      getterSetter: function(config, option) {
        const me = this;
        this[option] = function(value) {
          if (!arguments.length) {
            return config[option];
          }
          config[option] = value;
          return me;
        };
      },
      sgn: function(v) {
        if (v < 0) {
          return -1;
        }
        if (v > 0) {
          return 1;
        }
        return 0;
      },
      clamp: function(v, vMin, vMax) {
        if (v < vMin)
          return vMin;
        if (v > vMax)
          return vMax;
        return v;
      },
      color: function(data, index) {
        const indexModLenColor = index % globals_1.default.COLORS.length;
        return data.color || globals_1.default.COLORS[indexModLenColor].hex();
      },
      /**
       * Infinity is a value that is close to Infinity but not Infinity, it can fit in a JS number.
       */
      infinity: function() {
        return 9007199254740991;
      }
    };
    exports.default = utils;
  }
});

// node_modules/mr-parser/lib/token-type.js
var require_token_type = __commonJS({
  "node_modules/mr-parser/lib/token-type.js"(exports, module) {
    module.exports = {
      EOF: 0,
      DELIMITER: 1,
      NUMBER: 2,
      STRING: 3,
      SYMBOL: 4
    };
  }
});

// node_modules/mr-parser/lib/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/mr-parser/lib/Lexer.js"(exports, module) {
    var tokenType = require_token_type();
    var ESCAPES = {
      "n": "\n",
      "f": "\f",
      "r": "\r",
      "t": "	",
      "v": "\v",
      "'": "'",
      '"': '"'
    };
    var DELIMITERS = {
      ",": true,
      "(": true,
      ")": true,
      "[": true,
      "]": true,
      ";": true,
      // unary
      "~": true,
      // factorial
      "!": true,
      // arithmetic operators
      "+": true,
      "-": true,
      "*": true,
      "/": true,
      "%": true,
      "^": true,
      "**": true,
      // python power like
      // misc operators
      "|": true,
      // bitwise or
      "&": true,
      // bitwise and
      "^|": true,
      // bitwise xor
      "=": true,
      ":": true,
      "?": true,
      "||": true,
      // logical or
      "&&": true,
      // logical and
      "xor": true,
      // logical xor
      // relational
      "==": true,
      "!=": true,
      "===": true,
      "!==": true,
      "<": true,
      ">": true,
      ">=": true,
      "<=": true,
      // shifts
      ">>>": true,
      "<<": true,
      ">>": true
    };
    function isDigit(c2) {
      return c2 >= "0" && c2 <= "9";
    }
    function isIdentifier(c2) {
      return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_";
    }
    function isWhitespace(c2) {
      return c2 === " " || c2 === "\r" || c2 === "	" || c2 === "\n" || c2 === "\v" || c2 === " ";
    }
    function isDelimiter(str) {
      return DELIMITERS[str];
    }
    function isQuote(c2) {
      return c2 === "'" || c2 === '"';
    }
    function Lexer() {
    }
    Lexer.prototype.throwError = function(message, index) {
      index = typeof index === "undefined" ? this.index : index;
      var error = new Error(message + " at index " + index);
      error.index = index;
      error.description = message;
      throw error;
    };
    Lexer.prototype.lex = function(text) {
      this.text = text;
      this.index = 0;
      this.tokens = [];
      while (this.index < this.text.length) {
        while (isWhitespace(this.peek())) {
          this.consume();
        }
        var c2 = this.peek();
        var c22 = c2 + this.peek(1);
        var c3 = c22 + this.peek(2);
        if (isDelimiter(c3)) {
          this.tokens.push({
            type: tokenType.DELIMITER,
            value: c3
          });
          this.consume();
          this.consume();
          this.consume();
        } else if (isDelimiter(c22)) {
          this.tokens.push({
            type: tokenType.DELIMITER,
            value: c22
          });
          this.consume();
          this.consume();
        } else if (isDelimiter(c2)) {
          this.tokens.push({
            type: tokenType.DELIMITER,
            value: c2
          });
          this.consume();
        } else if (isDigit(c2) || c2 === "." && isDigit(this.peek(1))) {
          this.tokens.push({
            type: tokenType.NUMBER,
            value: this.readNumber()
          });
        } else if (isQuote(c2)) {
          this.tokens.push({
            type: tokenType.STRING,
            value: this.readString()
          });
        } else if (isIdentifier(c2)) {
          this.tokens.push({
            type: tokenType.SYMBOL,
            value: this.readIdentifier()
          });
        } else {
          this.throwError("unexpected character " + c2);
        }
      }
      this.tokens.push({ type: tokenType.EOF });
      return this.tokens;
    };
    Lexer.prototype.peek = function(nth) {
      nth = nth || 0;
      if (this.index + nth >= this.text.length) {
        return;
      }
      return this.text.charAt(this.index + nth);
    };
    Lexer.prototype.consume = function() {
      var current = this.peek();
      this.index += 1;
      return current;
    };
    Lexer.prototype.readNumber = function() {
      var number = "";
      if (this.peek() === ".") {
        number += this.consume();
        if (!isDigit(this.peek())) {
          this.throwError("number expected");
        }
      } else {
        while (isDigit(this.peek())) {
          number += this.consume();
        }
        if (this.peek() === ".") {
          number += this.consume();
        }
      }
      while (isDigit(this.peek())) {
        number += this.consume();
      }
      if (this.peek() === "e" || this.peek() === "E") {
        number += this.consume();
        if (!(isDigit(this.peek()) || this.peek() === "+" || this.peek() === "-")) {
          this.throwError();
        }
        if (this.peek() === "+" || this.peek() === "-") {
          number += this.consume();
        }
        if (!isDigit(this.peek())) {
          this.throwError("number expected");
        }
        while (isDigit(this.peek())) {
          number += this.consume();
        }
      }
      return number;
    };
    Lexer.prototype.readIdentifier = function() {
      var text = "";
      while (isIdentifier(this.peek()) || isDigit(this.peek())) {
        text += this.consume();
      }
      return text;
    };
    Lexer.prototype.readString = function() {
      var quote = this.consume();
      var string = "";
      var escape;
      while (true) {
        var c2 = this.consume();
        if (!c2) {
          this.throwError("string is not closed");
        }
        if (escape) {
          if (c2 === "u") {
            var hex2 = this.text.substring(this.index + 1, this.index + 5);
            if (!hex2.match(/[\da-f]{4}/i)) {
              this.throwError("invalid unicode escape");
            }
            this.index += 4;
            string += String.fromCharCode(parseInt(hex2, 16));
          } else {
            var replacement = ESCAPES[c2];
            if (replacement) {
              string += replacement;
            } else {
              string += c2;
            }
          }
          escape = false;
        } else if (c2 === quote) {
          break;
        } else if (c2 === "\\") {
          escape = true;
        } else {
          string += c2;
        }
      }
      return string;
    };
    module.exports = Lexer;
  }
});

// node_modules/mr-parser/lib/node/Node.js
var require_Node = __commonJS({
  "node_modules/mr-parser/lib/node/Node.js"(exports, module) {
    function Node() {
    }
    Node.prototype.type = "Node";
    module.exports = Node;
  }
});

// node_modules/mr-parser/lib/node/ConstantNode.js
var require_ConstantNode = __commonJS({
  "node_modules/mr-parser/lib/node/ConstantNode.js"(exports, module) {
    var Node = require_Node();
    var SUPPORTED_TYPES = {
      number: true,
      string: true,
      "boolean": true,
      "undefined": true,
      "null": true
    };
    function ConstantNode(value, type) {
      if (!SUPPORTED_TYPES[type]) {
        throw Error("unsupported type '" + type + "'");
      }
      this.value = value;
      this.valueType = type;
    }
    ConstantNode.prototype = Object.create(Node.prototype);
    ConstantNode.prototype.type = "ConstantNode";
    module.exports = ConstantNode;
  }
});

// node_modules/mr-parser/lib/node/OperatorNode.js
var require_OperatorNode = __commonJS({
  "node_modules/mr-parser/lib/node/OperatorNode.js"(exports, module) {
    var Node = require_Node();
    function OperatorNode(op, args) {
      this.op = op;
      this.args = args || [];
    }
    OperatorNode.prototype = Object.create(Node.prototype);
    OperatorNode.prototype.type = "OperatorNode";
    module.exports = OperatorNode;
  }
});

// node_modules/mr-parser/lib/node/UnaryNode.js
var require_UnaryNode = __commonJS({
  "node_modules/mr-parser/lib/node/UnaryNode.js"(exports, module) {
    var Node = require_Node();
    function UnaryNode(op, argument) {
      this.op = op;
      this.argument = argument;
    }
    UnaryNode.prototype = Object.create(Node.prototype);
    UnaryNode.prototype.type = "UnaryNode";
    module.exports = UnaryNode;
  }
});

// node_modules/mr-parser/lib/node/SymbolNode.js
var require_SymbolNode = __commonJS({
  "node_modules/mr-parser/lib/node/SymbolNode.js"(exports, module) {
    var Node = require_Node();
    function SymbolNode(name) {
      this.name = name;
    }
    SymbolNode.prototype = Object.create(Node.prototype);
    SymbolNode.prototype.type = "SymbolNode";
    module.exports = SymbolNode;
  }
});

// node_modules/mr-parser/lib/node/FunctionNode.js
var require_FunctionNode = __commonJS({
  "node_modules/mr-parser/lib/node/FunctionNode.js"(exports, module) {
    var Node = require_Node();
    function FunctionNode(name, args) {
      this.name = name;
      this.args = args;
    }
    FunctionNode.prototype = Object.create(Node.prototype);
    FunctionNode.prototype.type = "FunctionNode";
    module.exports = FunctionNode;
  }
});

// node_modules/mr-parser/lib/node/ArrayNode.js
var require_ArrayNode = __commonJS({
  "node_modules/mr-parser/lib/node/ArrayNode.js"(exports, module) {
    var Node = require_Node();
    function ArrayNode(nodes) {
      this.nodes = nodes;
    }
    ArrayNode.prototype = Object.create(Node.prototype);
    ArrayNode.prototype.type = "ArrayNode";
    module.exports = ArrayNode;
  }
});

// node_modules/mr-parser/lib/node/ConditionalNode.js
var require_ConditionalNode = __commonJS({
  "node_modules/mr-parser/lib/node/ConditionalNode.js"(exports, module) {
    var Node = require_Node();
    function ConditionalNode(predicate, truthy, falsy) {
      this.condition = predicate;
      this.trueExpr = truthy;
      this.falseExpr = falsy;
    }
    ConditionalNode.prototype = Object.create(Node.prototype);
    ConditionalNode.prototype.type = "ConditionalNode";
    module.exports = ConditionalNode;
  }
});

// node_modules/mr-parser/lib/node/AssignmentNode.js
var require_AssignmentNode = __commonJS({
  "node_modules/mr-parser/lib/node/AssignmentNode.js"(exports, module) {
    var Node = require_Node();
    function AssignmentNode(name, expr) {
      this.name = name;
      this.expr = expr;
    }
    AssignmentNode.prototype = Object.create(Node.prototype);
    AssignmentNode.prototype.type = "AssignmentNode";
    module.exports = AssignmentNode;
  }
});

// node_modules/mr-parser/lib/node/BlockNode.js
var require_BlockNode = __commonJS({
  "node_modules/mr-parser/lib/node/BlockNode.js"(exports, module) {
    var Node = require_Node();
    function BlockNode(blocks) {
      this.blocks = blocks;
    }
    BlockNode.prototype = Object.create(Node.prototype);
    BlockNode.prototype.type = "BlockNode";
    module.exports = BlockNode;
  }
});

// node_modules/mr-parser/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/mr-parser/lib/Parser.js"(exports, module) {
    var tokenType = require_token_type();
    var Lexer = require_Lexer();
    var ConstantNode = require_ConstantNode();
    var OperatorNode = require_OperatorNode();
    var UnaryNode = require_UnaryNode();
    var SymbolNode = require_SymbolNode();
    var FunctionNode = require_FunctionNode();
    var ArrayNode = require_ArrayNode();
    var ConditionalNode = require_ConditionalNode();
    var AssignmentNode = require_AssignmentNode();
    var BlockNode = require_BlockNode();
    function Parser() {
      this.lexer = new Lexer();
      this.tokens = null;
    }
    Parser.prototype.current = function() {
      return this.tokens[0];
    };
    Parser.prototype.next = function() {
      return this.tokens[1];
    };
    Parser.prototype.peek = function() {
      if (this.tokens.length) {
        var first = this.tokens[0];
        for (var i = 0; i < arguments.length; i += 1) {
          if (first.value === arguments[i]) {
            return true;
          }
        }
      }
    };
    Parser.prototype.consume = function(e) {
      return this.tokens.shift();
    };
    Parser.prototype.expect = function(e) {
      if (!this.peek(e)) {
        throw Error("expected " + e);
      }
      return this.consume();
    };
    Parser.prototype.isEOF = function() {
      return this.current().type === tokenType.EOF;
    };
    Parser.prototype.parse = function(text) {
      this.tokens = this.lexer.lex(text);
      return this.program();
    };
    Parser.prototype.program = function() {
      var blocks = [];
      while (!this.isEOF()) {
        blocks.push(this.assignment());
        if (this.peek(";")) {
          this.consume();
        }
      }
      this.end();
      return new BlockNode(blocks);
    };
    Parser.prototype.assignment = function() {
      var left = this.ternary();
      if (left instanceof SymbolNode && this.peek("=")) {
        this.consume();
        return new AssignmentNode(left.name, this.assignment());
      }
      return left;
    };
    Parser.prototype.ternary = function() {
      var predicate = this.logicalOR();
      if (this.peek("?")) {
        this.consume();
        var truthy = this.ternary();
        this.expect(":");
        var falsy = this.ternary();
        return new ConditionalNode(predicate, truthy, falsy);
      }
      return predicate;
    };
    Parser.prototype.logicalOR = function() {
      var left = this.logicalXOR();
      if (this.peek("||")) {
        var op = this.consume();
        var right = this.logicalOR();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.logicalXOR = function() {
      var left = this.logicalAND();
      if (this.current().value === "xor") {
        var op = this.consume();
        var right = this.logicalXOR();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.logicalAND = function() {
      var left = this.bitwiseOR();
      if (this.peek("&&")) {
        var op = this.consume();
        var right = this.logicalAND();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.bitwiseOR = function() {
      var left = this.bitwiseXOR();
      if (this.peek("|")) {
        var op = this.consume();
        var right = this.bitwiseOR();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.bitwiseXOR = function() {
      var left = this.bitwiseAND();
      if (this.peek("^|")) {
        var op = this.consume();
        var right = this.bitwiseXOR();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.bitwiseAND = function() {
      var left = this.relational();
      if (this.peek("&")) {
        var op = this.consume();
        var right = this.bitwiseAND();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.relational = function() {
      var left = this.shift();
      if (this.peek("==", "===", "!=", "!==", ">=", "<=", ">", "<")) {
        var op = this.consume();
        var right = this.shift();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.shift = function() {
      var left = this.additive();
      if (this.peek(">>", "<<", ">>>")) {
        var op = this.consume();
        var right = this.shift();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.additive = function() {
      var left = this.multiplicative();
      while (this.peek("+", "-")) {
        var op = this.consume();
        left = new OperatorNode(op.value, [left, this.multiplicative()]);
      }
      return left;
    };
    Parser.prototype.multiplicative = function() {
      var op, right;
      var left = this.unary();
      while (this.peek("*", "/", "%")) {
        op = this.consume();
        left = new OperatorNode(op.value, [left, this.unary()]);
      }
      if (this.current().type === tokenType.SYMBOL || this.peek("(") || !(left.type instanceof ConstantNode) && this.current().type === tokenType.NUMBER) {
        right = this.multiplicative();
        return new OperatorNode("*", [left, right]);
      }
      return left;
    };
    Parser.prototype.unary = function() {
      if (this.peek("-", "+", "~")) {
        var op = this.consume();
        var right = this.unary();
        return new UnaryNode(op.value, right);
      }
      return this.pow();
    };
    Parser.prototype.pow = function() {
      var left = this.factorial();
      if (this.peek("^", "**")) {
        var op = this.consume();
        var right = this.unary();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.factorial = function() {
      var left = this.symbol();
      if (this.peek("!")) {
        var op = this.consume();
        return new OperatorNode(op.value, [left]);
      }
      return left;
    };
    Parser.prototype.symbol = function() {
      var current = this.current();
      if (current.type === tokenType.SYMBOL) {
        var symbol = this.consume();
        var node = this.functionCall(symbol);
        return node;
      }
      return this.string();
    };
    Parser.prototype.functionCall = function(symbolToken) {
      var name = symbolToken.value;
      if (this.peek("(")) {
        this.consume();
        var params = [];
        while (!this.peek(")") && !this.isEOF()) {
          params.push(this.assignment());
          if (this.peek(",")) {
            this.consume();
          }
        }
        this.expect(")");
        return new FunctionNode(name, params);
      }
      return new SymbolNode(name);
    };
    Parser.prototype.string = function() {
      if (this.current().type === tokenType.STRING) {
        return new ConstantNode(this.consume().value, "string");
      }
      return this.array();
    };
    Parser.prototype.array = function() {
      if (this.peek("[")) {
        this.consume();
        var params = [];
        while (!this.peek("]") && !this.isEOF()) {
          params.push(this.assignment());
          if (this.peek(",")) {
            this.consume();
          }
        }
        this.expect("]");
        return new ArrayNode(params);
      }
      return this.number();
    };
    Parser.prototype.number = function() {
      var token = this.current();
      if (token.type === tokenType.NUMBER) {
        return new ConstantNode(this.consume().value, "number");
      }
      return this.parentheses();
    };
    Parser.prototype.parentheses = function() {
      var token = this.current();
      if (token.value === "(") {
        this.consume();
        var left = this.assignment();
        this.expect(")");
        return left;
      }
      return this.end();
    };
    Parser.prototype.end = function() {
      var token = this.current();
      if (token.type !== tokenType.EOF) {
        throw Error("unexpected end of expression");
      }
    };
    module.exports = Parser;
  }
});

// node_modules/mr-parser/lib/node/index.js
var require_node = __commonJS({
  "node_modules/mr-parser/lib/node/index.js"(exports, module) {
    module.exports = {
      ArrayNode: require_ArrayNode(),
      AssignmentNode: require_AssignmentNode(),
      BlockNode: require_BlockNode(),
      ConditionalNode: require_ConditionalNode(),
      ConstantNode: require_ConstantNode(),
      FunctionNode: require_FunctionNode(),
      Node: require_Node(),
      OperatorNode: require_OperatorNode(),
      SymbolNode: require_SymbolNode(),
      UnaryNode: require_UnaryNode()
    };
  }
});

// node_modules/mr-parser/index.js
var require_mr_parser = __commonJS({
  "node_modules/mr-parser/index.js"(exports, module) {
    "use strict";
    module.exports.Lexer = require_Lexer();
    module.exports.Parser = require_Parser();
    module.exports.nodeTypes = require_node();
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend2() {
      var options, name, src, copy, copyIsArray, clone2;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone2, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ArrayNode.js
var require_ArrayNode2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ArrayNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var self = this;
      var arr = [];
      this.rawify(this.options.rawArrayExpressionElements, function() {
        arr = node.nodes.map(function(el) {
          return self.next(el);
        });
      });
      var arrString = "[" + arr.join(",") + "]";
      if (this.options.raw) {
        return arrString;
      }
      return this.options.factory + "(" + arrString + ")";
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/AssignmentNode.js
var require_AssignmentNode2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/AssignmentNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      return 'scope["' + node.name + '"] = ' + this.next(node.expr);
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConditionalNode.js
var require_ConditionalNode2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConditionalNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var condition = "!!(" + this.next(node.condition) + ")";
      var trueExpr = this.next(node.trueExpr);
      var falseExpr = this.next(node.falseExpr);
      return "(" + condition + " ? (" + trueExpr + ") : (" + falseExpr + ") )";
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConstantNode.js
var require_ConstantNode2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConstantNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      if (this.options.raw) {
        return node.value;
      }
      return this.options.factory + "(" + node.value + ")";
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/FunctionNode.js
var require_FunctionNode2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/FunctionNode.js"(exports, module) {
    "use strict";
    var SymbolNode = require_mr_parser().nodeTypes.SymbolNode;
    var functionProxy = function(node) {
      return "$$mathCodegen.functionProxy(" + this.next(new SymbolNode(node.name)) + ', "' + node.name + '")';
    };
    module.exports = function(node) {
      var self = this;
      var method = functionProxy.call(this, node);
      var args = [];
      this.rawify(this.options.rawCallExpressionElements, function() {
        args = node.args.map(function(arg) {
          return self.next(arg);
        });
      });
      return method + "(" + args.join(", ") + ")";
    };
    module.exports.functionProxy = functionProxy;
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/Operators.js
var require_Operators = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/Operators.js"(exports, module) {
    "use strict";
    module.exports = {
      // arithmetic
      "+": "add",
      "-": "sub",
      "*": "mul",
      "/": "div",
      "^": "pow",
      "%": "mod",
      "!": "factorial",
      // misc operators
      "|": "bitwiseOR",
      // bitwise or
      "^|": "bitwiseXOR",
      // bitwise xor
      "&": "bitwiseAND",
      // bitwise and
      "||": "logicalOR",
      // logical or
      "xor": "logicalXOR",
      // logical xor
      "&&": "logicalAND",
      // logical and
      // comparison
      "<": "lessThan",
      ">": "greaterThan",
      "<=": "lessEqualThan",
      ">=": "greaterEqualThan",
      "===": "strictlyEqual",
      "==": "equal",
      "!==": "strictlyNotEqual",
      "!=": "notEqual",
      // shift
      ">>": "shiftRight",
      "<<": "shiftLeft",
      ">>>": "unsignedRightShift"
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/OperatorNode.js
var require_OperatorNode2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/OperatorNode.js"(exports, module) {
    "use strict";
    var Operators = require_Operators();
    module.exports = function(node) {
      if (this.options.raw) {
        return ["(" + this.next(node.args[0]), node.op, this.next(node.args[1]) + ")"].join(" ");
      }
      var namedOperator = Operators[node.op];
      if (!namedOperator) {
        throw TypeError("unidentified operator");
      }
      return this.FunctionNode({
        name: namedOperator,
        args: node.args
      });
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/SymbolNode.js
var require_SymbolNode2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/SymbolNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var id = node.name;
      return '$$mathCodegen.getProperty("' + id + '", scope, ns)';
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/UnaryOperators.js
var require_UnaryOperators = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/UnaryOperators.js"(exports, module) {
    "use strict";
    module.exports = {
      "+": "positive",
      "-": "negative",
      "~": "oneComplement"
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/UnaryNode.js
var require_UnaryNode2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/UnaryNode.js"(exports, module) {
    "use strict";
    var UnaryOperators = require_UnaryOperators();
    module.exports = function(node) {
      if (this.options.raw) {
        return node.op + this.next(node.argument);
      }
      if (!(node.op in UnaryOperators)) {
        throw new SyntaxError(node.op + " not implemented");
      }
      var namedOperator = UnaryOperators[node.op];
      return this.FunctionNode({
        name: namedOperator,
        args: [node.argument]
      });
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/Interpreter.js
var require_Interpreter = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/Interpreter.js"(exports, module) {
    "use strict";
    var extend2 = require_extend();
    var types = {
      ArrayNode: require_ArrayNode2(),
      AssignmentNode: require_AssignmentNode2(),
      ConditionalNode: require_ConditionalNode2(),
      ConstantNode: require_ConstantNode2(),
      FunctionNode: require_FunctionNode2(),
      OperatorNode: require_OperatorNode2(),
      SymbolNode: require_SymbolNode2(),
      UnaryNode: require_UnaryNode2()
    };
    var Interpreter = function(owner, options) {
      this.owner = owner;
      this.options = extend2({
        factory: "ns.factory",
        raw: false,
        rawArrayExpressionElements: true,
        rawCallExpressionElements: false,
        applyFactoryToScope: false
      }, options);
    };
    extend2(Interpreter.prototype, types);
    Interpreter.prototype.next = function(node) {
      if (!(node.type in this)) {
        throw new TypeError("the node type " + node.type + " is not implemented");
      }
      return this[node.type](node);
    };
    Interpreter.prototype.rawify = function(test, fn) {
      var oldRaw = this.options.raw;
      if (test) {
        this.options.raw = true;
      }
      fn();
      if (test) {
        this.options.raw = oldRaw;
      }
    };
    module.exports = Interpreter;
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/CodeGenerator.js
var require_CodeGenerator = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/CodeGenerator.js"(exports, module) {
    "use strict";
    var Parser = require_mr_parser().Parser;
    var Interpreter = require_Interpreter();
    var extend2 = require_extend();
    function CodeGenerator(options, defs) {
      this.statements = [];
      this.defs = defs || {};
      this.interpreter = new Interpreter(this, options);
    }
    CodeGenerator.prototype.setDefs = function(defs) {
      this.defs = extend2(this.defs, defs);
      return this;
    };
    CodeGenerator.prototype.compile = function(namespace) {
      var self = this;
      if (!namespace || !(typeof namespace === "object" || typeof namespace === "function")) {
        throw TypeError("namespace must be an object");
      }
      if (typeof namespace.factory !== "function") {
        throw TypeError("namespace.factory must be a function");
      }
      this.defs.ns = namespace;
      this.defs.$$mathCodegen = {
        getProperty: function(symbol, scope, ns) {
          function applyFactoryIfNeeded(value) {
            if (self.interpreter.options.applyFactoryToScope && typeof value !== "function") {
              return ns.factory(value);
            }
            return value;
          }
          if (symbol in scope) {
            return applyFactoryIfNeeded(scope[symbol]);
          }
          if (symbol in ns) {
            return applyFactoryIfNeeded(ns[symbol]);
          }
          throw SyntaxError('symbol "' + symbol + '" is undefined');
        },
        functionProxy: function(fn, name) {
          if (typeof fn !== "function") {
            throw SyntaxError('symbol "' + name + '" must be a function');
          }
          return fn;
        }
      };
      this.defs.$$processScope = this.defs.$$processScope || function() {
      };
      var defsCode = Object.keys(this.defs).map(function(name) {
        return "var " + name + ' = defs["' + name + '"]';
      });
      if (!this.statements.length) {
        throw Error("there are no statements saved in this generator, make sure you parse an expression before compiling it");
      }
      this.statements[this.statements.length - 1] = "return " + this.statements[this.statements.length - 1];
      var code = this.statements.join(";");
      var factoryCode = defsCode.join("\n") + "\n" + [
        "return {",
        "  eval: function (scope) {",
        "    scope = scope || {}",
        "    $$processScope(scope)",
        "    " + code,
        "  },",
        "  code: '" + code + "'",
        "}"
      ].join("\n");
      var factory = new Function("defs", factoryCode);
      return factory(this.defs);
    };
    CodeGenerator.prototype.parse = function(code) {
      var self = this;
      var program = new Parser().parse(code);
      this.statements = program.blocks.map(function(statement) {
        return self.interpreter.next(statement);
      });
      return this;
    };
    module.exports = CodeGenerator;
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/index.js
var require_math_codegen = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/index.js"(exports, module) {
    "use strict";
    module.exports = require_CodeGenerator();
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasInterval: () => hasInterval,
  hasValue: () => hasValue,
  intervalsOverlap: () => intervalsOverlap,
  isEmpty: () => isEmpty,
  isInterval: () => isInterval,
  isSingleton: () => isSingleton,
  isWhole: () => isWhole,
  zeroIn: () => zeroIn
});
function isInterval(x2) {
  return typeof x2 === "object" && typeof x2.lo === "number" && typeof x2.hi === "number";
}
function isEmpty(i) {
  return i.lo > i.hi;
}
function isWhole(i) {
  return i.lo === -Infinity && i.hi === Infinity;
}
function isSingleton(i) {
  return i.lo === i.hi;
}
function zeroIn(i) {
  return hasValue(i, 0);
}
function hasValue(i, value) {
  if (isEmpty(i)) {
    return false;
  }
  return i.lo <= value && value <= i.hi;
}
function hasInterval(x2, y2) {
  if (isEmpty(x2)) {
    return true;
  }
  return !isEmpty(y2) && y2.lo <= x2.lo && x2.hi <= y2.hi;
}
function intervalsOverlap(x2, y2) {
  if (isEmpty(x2) || isEmpty(y2)) {
    return false;
  }
  return x2.lo <= y2.lo && y2.lo <= x2.hi || y2.lo <= x2.lo && x2.lo <= y2.hi;
}
var init_utils = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/utils.js"() {
  }
});

// node_modules/double-bits/double.js
var require_double = __commonJS({
  "node_modules/double-bits/double.js"(exports, module) {
    var hasTypedArrays = false;
    if (typeof Float64Array !== "undefined") {
      DOUBLE_VIEW = new Float64Array(1), UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer);
      DOUBLE_VIEW[0] = 1;
      hasTypedArrays = true;
      if (UINT_VIEW[1] === 1072693248) {
        let toDoubleLE2 = function(lo, hi) {
          UINT_VIEW[0] = lo;
          UINT_VIEW[1] = hi;
          return DOUBLE_VIEW[0];
        }, lowUintLE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[0];
        }, highUintLE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[1];
        };
        toDoubleLE = toDoubleLE2, lowUintLE = lowUintLE2, highUintLE = highUintLE2;
        module.exports = function doubleBitsLE(n) {
          DOUBLE_VIEW[0] = n;
          return [UINT_VIEW[0], UINT_VIEW[1]];
        };
        module.exports.pack = toDoubleLE2;
        module.exports.lo = lowUintLE2;
        module.exports.hi = highUintLE2;
      } else if (UINT_VIEW[0] === 1072693248) {
        let toDoubleBE2 = function(lo, hi) {
          UINT_VIEW[1] = lo;
          UINT_VIEW[0] = hi;
          return DOUBLE_VIEW[0];
        }, lowUintBE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[1];
        }, highUintBE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[0];
        };
        toDoubleBE = toDoubleBE2, lowUintBE = lowUintBE2, highUintBE = highUintBE2;
        module.exports = function doubleBitsBE(n) {
          DOUBLE_VIEW[0] = n;
          return [UINT_VIEW[1], UINT_VIEW[0]];
        };
        module.exports.pack = toDoubleBE2;
        module.exports.lo = lowUintBE2;
        module.exports.hi = highUintBE2;
      } else {
        hasTypedArrays = false;
      }
    }
    var DOUBLE_VIEW;
    var UINT_VIEW;
    var toDoubleLE;
    var lowUintLE;
    var highUintLE;
    var toDoubleBE;
    var lowUintBE;
    var highUintBE;
    if (!hasTypedArrays) {
      let toDouble2 = function(lo, hi) {
        buffer.writeUInt32LE(lo, 0, true);
        buffer.writeUInt32LE(hi, 4, true);
        return buffer.readDoubleLE(0, true);
      }, lowUint2 = function(n) {
        buffer.writeDoubleLE(n, 0, true);
        return buffer.readUInt32LE(0, true);
      }, highUint2 = function(n) {
        buffer.writeDoubleLE(n, 0, true);
        return buffer.readUInt32LE(4, true);
      };
      toDouble = toDouble2, lowUint = lowUint2, highUint = highUint2;
      buffer = new Buffer(8);
      module.exports = function doubleBits(n) {
        buffer.writeDoubleLE(n, 0, true);
        return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];
      };
      module.exports.pack = toDouble2;
      module.exports.lo = lowUint2;
      module.exports.hi = highUint2;
    }
    var buffer;
    var toDouble;
    var lowUint;
    var highUint;
    module.exports.sign = function(n) {
      return module.exports.hi(n) >>> 31;
    };
    module.exports.exponent = function(n) {
      var b = module.exports.hi(n);
      return (b << 1 >>> 21) - 1023;
    };
    module.exports.fraction = function(n) {
      var lo = module.exports.lo(n);
      var hi = module.exports.hi(n);
      var b = hi & (1 << 20) - 1;
      if (hi & 2146435072) {
        b += 1 << 20;
      }
      return [lo, b];
    };
    module.exports.denormalized = function(n) {
      var hi = module.exports.hi(n);
      return !(hi & 2146435072);
    };
  }
});

// node_modules/nextafter/nextafter.js
var require_nextafter = __commonJS({
  "node_modules/nextafter/nextafter.js"(exports, module) {
    "use strict";
    var doubleBits = require_double();
    var SMALLEST_DENORM = Math.pow(2, -1074);
    var UINT_MAX = -1 >>> 0;
    module.exports = nextafter2;
    function nextafter2(x2, y2) {
      if (isNaN(x2) || isNaN(y2)) {
        return NaN;
      }
      if (x2 === y2) {
        return x2;
      }
      if (x2 === 0) {
        if (y2 < 0) {
          return -SMALLEST_DENORM;
        } else {
          return SMALLEST_DENORM;
        }
      }
      var hi = doubleBits.hi(x2);
      var lo = doubleBits.lo(x2);
      if (y2 > x2 === x2 > 0) {
        if (lo === UINT_MAX) {
          hi += 1;
          lo = 0;
        } else {
          lo += 1;
        }
      } else {
        if (lo === 0) {
          lo = UINT_MAX;
          hi -= 1;
        } else {
          lo -= 1;
        }
      }
      return doubleBits.pack(lo, hi);
    }
  }
});

// node_modules/interval-arithmetic/lib-esm/round.js
function identity(v) {
  return v;
}
function prev(v) {
  if (v === Infinity) {
    return v;
  }
  return (0, import_nextafter.default)(v, -Infinity);
}
function next(v) {
  if (v === -Infinity) {
    return v;
  }
  return (0, import_nextafter.default)(v, Infinity);
}
function toInteger(x2) {
  return x2 < 0 ? Math.ceil(x2) : Math.floor(x2);
}
var import_nextafter, cache, round, round_default;
var init_round = __esm({
  "node_modules/interval-arithmetic/lib-esm/round.js"() {
    import_nextafter = __toESM(require_nextafter());
    cache = {
      prev,
      next
    };
    round = {
      /**
       * Computes the previous IEEE floating point representation of `v`
       * @example
       * Interval.round.safePrev(1)          // 0.9999999999999999
       * Interval.round.safePrev(3)          // 2.9999999999999996
       * Interval.round.safePrev(Infinity)   // Infinity
       * @param {number} v
       * @return {number}
       * @function
       */
      safePrev: prev,
      /**
       * Computes the next IEEE floating point representation of `v`
       * @example
       * Interval.round.safeNext(1)          // 1.0000000000000002
       * Interval.round.safeNext(3)          // 3.0000000000000004
       * Interval.round.safeNext(-Infinity)  // -Infinity
       * @param {number} v
       * @return {number}
       * @function
       */
      safeNext: next,
      prev(x2) {
        return cache.prev(x2);
      },
      next(x2) {
        return cache.next(x2);
      },
      // prettier-ignore
      addLo(x2, y2) {
        return round.prev(x2 + y2);
      },
      // prettier-ignore
      addHi(x2, y2) {
        return round.next(x2 + y2);
      },
      // prettier-ignore
      subLo(x2, y2) {
        return round.prev(x2 - y2);
      },
      // prettier-ignore
      subHi(x2, y2) {
        return round.next(x2 - y2);
      },
      // prettier-ignore
      mulLo(x2, y2) {
        return round.prev(x2 * y2);
      },
      // prettier-ignore
      mulHi(x2, y2) {
        return round.next(x2 * y2);
      },
      // prettier-ignore
      divLo(x2, y2) {
        return round.prev(x2 / y2);
      },
      // prettier-ignore
      divHi(x2, y2) {
        return round.next(x2 / y2);
      },
      // prettier-ignore
      intLo(x2) {
        return toInteger(round.prev(x2));
      },
      // prettier-ignore
      intHi(x2) {
        return toInteger(round.next(x2));
      },
      // prettier-ignore
      logLo(x2) {
        return round.prev(Math.log(x2));
      },
      // prettier-ignore
      logHi(x2) {
        return round.next(Math.log(x2));
      },
      // prettier-ignore
      expLo(x2) {
        return round.prev(Math.exp(x2));
      },
      // prettier-ignore
      expHi(x2) {
        return round.next(Math.exp(x2));
      },
      // prettier-ignore
      sinLo(x2) {
        return round.prev(Math.sin(x2));
      },
      // prettier-ignore
      sinHi(x2) {
        return round.next(Math.sin(x2));
      },
      // prettier-ignore
      cosLo(x2) {
        return round.prev(Math.cos(x2));
      },
      // prettier-ignore
      cosHi(x2) {
        return round.next(Math.cos(x2));
      },
      // prettier-ignore
      tanLo(x2) {
        return round.prev(Math.tan(x2));
      },
      // prettier-ignore
      tanHi(x2) {
        return round.next(Math.tan(x2));
      },
      // prettier-ignore
      asinLo(x2) {
        return round.prev(Math.asin(x2));
      },
      // prettier-ignore
      asinHi(x2) {
        return round.next(Math.asin(x2));
      },
      // prettier-ignore
      acosLo(x2) {
        return round.prev(Math.acos(x2));
      },
      // prettier-ignore
      acosHi(x2) {
        return round.next(Math.acos(x2));
      },
      // prettier-ignore
      atanLo(x2) {
        return round.prev(Math.atan(x2));
      },
      // prettier-ignore
      atanHi(x2) {
        return round.next(Math.atan(x2));
      },
      // polyfill required for hyperbolic functions
      // prettier-ignore
      sinhLo(x2) {
        return round.prev(Math.sinh(x2));
      },
      // prettier-ignore
      sinhHi(x2) {
        return round.next(Math.sinh(x2));
      },
      // prettier-ignore
      coshLo(x2) {
        return round.prev(Math.cosh(x2));
      },
      // prettier-ignore
      coshHi(x2) {
        return round.next(Math.cosh(x2));
      },
      // prettier-ignore
      tanhLo(x2) {
        return round.prev(Math.tanh(x2));
      },
      // prettier-ignore
      tanhHi(x2) {
        return round.next(Math.tanh(x2));
      },
      /**
       * @ignore
       * ln(power) exponentiation of x
       * @param {number} x
       * @param {number} power
       * @returns {number}
       */
      powLo(x2, power) {
        if (power % 1 !== 0) {
          return round.prev(Math.pow(x2, power));
        }
        let y2 = (power & 1) === 1 ? x2 : 1;
        power >>= 1;
        while (power > 0) {
          x2 = round.mulLo(x2, x2);
          if ((power & 1) === 1) {
            y2 = round.mulLo(x2, y2);
          }
          power >>= 1;
        }
        return y2;
      },
      /**
       * @ignore
       * ln(power) exponentiation of x
       * @param {number} x
       * @param {number} power
       * @returns {number}
       */
      powHi(x2, power) {
        if (power % 1 !== 0) {
          return round.next(Math.pow(x2, power));
        }
        let y2 = (power & 1) === 1 ? x2 : 1;
        power >>= 1;
        while (power > 0) {
          x2 = round.mulHi(x2, x2);
          if ((power & 1) === 1) {
            y2 = round.mulHi(x2, y2);
          }
          power >>= 1;
        }
        return y2;
      },
      // prettier-ignore
      sqrtLo(x2) {
        return round.prev(Math.sqrt(x2));
      },
      // prettier-ignore
      sqrtHi(x2) {
        return round.next(Math.sqrt(x2));
      },
      /**
       * Most operations on intervals will cary the rounding error so that the
       * resulting interval correctly represents all the possible values, this feature
       * can be disabled by calling this method allowing a little boost in the
       * performance while operating on intervals
       *
       * @see module:interval-arithmetic/round-math.enable
       * @example
       * var x = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
       *
       * Interval.round.disable()
       * var y = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * y // equal to {lo: 2, hi: 2}
       * @function
       */
      disable() {
        cache.next = cache.prev = identity;
      },
      /**
       * Enables IEEE previous/next floating point wrapping of values (enabled by
       * default)
       * @see module:interval-arithmetic/round-math.disable
       * @example
       * var x = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
       *
       * Interval.round.disable()
       * var y = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * y // equal to {lo: 2, hi: 2}
       *
       * Interval.round.enable()
       * var z = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * z // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
       * @function
       */
      enable() {
        cache.next = next;
        cache.prev = prev;
      }
    };
    round_default = round;
  }
});

// node_modules/interval-arithmetic/lib-esm/interval.js
function bindNew(Class) {
  function _Class() {
    for (var len = arguments.length, rest = Array(len), key = 0; key < len; key++) {
      rest[key] = arguments[key];
    }
    return new (Function.prototype.bind.apply(Class, [null].concat(rest)))();
  }
  _Class.prototype = Class.prototype;
  return _Class;
}
var _Interval, Interval;
var init_interval = __esm({
  "node_modules/interval-arithmetic/lib-esm/interval.js"() {
    init_utils();
    init_round();
    _Interval = class __Interval {
      constructor(lo, hi) {
        this.lo = 0;
        this.hi = 0;
        if (!(this instanceof __Interval)) {
          console.log("calling with new");
          console.log(lo, hi);
          return new __Interval(lo, hi);
        }
        if (typeof lo !== "undefined" && typeof hi !== "undefined") {
          if (isInterval(lo)) {
            if (!isSingleton(lo)) {
              throw new TypeError("Interval: interval `lo` must be a singleton");
            }
            lo = lo.lo;
          }
          if (isInterval(hi)) {
            if (!isSingleton(hi)) {
              throw TypeError("Interval: interval `hi` must be a singleton");
            }
            hi = hi.hi;
          }
        } else if (typeof lo !== "undefined") {
          if (Array.isArray(lo)) {
            return new Interval(lo[0], lo[1]);
          }
          return new Interval(lo, lo);
        } else {
          lo = hi = 0;
        }
        this.assign(lo, hi);
      }
      /**
       * Sets `this.lo` and `this.hi` to a single value `v`
       *
       * @param {number} v
       * @return {Interval} The calling interval i.e. `this`
       */
      singleton(v) {
        return this.set(v, v);
      }
      /**
       * Sets new endpoints to this interval, the left endpoint is equal to the
       * previous IEEE floating point value of `lo` and the right endpoint
       * is equal to the next IEEE floating point
       * value of `hi`, it's assumed that `lo <= hi`
       *
       * @example
       * ```typescript
       * const x = Interval().bounded(1, 2)
       * x.lo < 1 // true, x.lo === 0.9999999999999999
       * x.hi > 2 // true, x.hi === 2.0000000000000004
       * ```
       *
       * @example
       * ```typescript
       * // the correct representation of 1/3
       * var x = Interval().bounded(1/3, 1/3)
       * x.lo < 1/3 // true
       * x.hi > 1/3 // true
       * // however the floating point representation of 1/3 is less than the real 1/3
       * // therefore the left endpoint could be 1/3 instead of the previous value of
       * var next = Interval.round.safeNext
       * var x = Interval().set(1/3, next(1/3))
       * // x now represents 1/3 correctly
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval i.e. `this`
       */
      bounded(lo, hi) {
        return this.set(round_default.prev(lo), round_default.next(hi));
      }
      /**
       * Equivalent to `Interval().bounded(v, v)`
       * @param {number} v
       * @return {Interval} The calling interval i.e. `this`
       */
      boundedSingleton(v) {
        return this.bounded(v, v);
      }
      /**
       * Sets new endpoints for this interval, this method bypasses any
       * checks on the type of arguments
       *
       * @param {Number} lo The left endpoint of the interval
       * @param {Number} hi The right endpoint of the interval
       * @return {Interval} The calling interval
       */
      set(lo, hi) {
        this.lo = lo;
        this.hi = hi;
        return this;
      }
      /**
       * Sets new endpoints for this interval checking that both arguments exist
       * and that are valid numbers, additionally if `lo > hi` the interval is set to
       * an empty interval
       *
       * @param {Number} lo The left endpoint of the interval
       * @param {Number} hi The right endpoint of the interval
       * @return {Interval} The calling interval
       */
      assign(lo, hi) {
        if (typeof lo !== "number" || typeof hi !== "number") {
          throw TypeError("Interval#assign: arguments must be numbers");
        }
        if (isNaN(lo) || isNaN(hi) || lo > hi) {
          return this.setEmpty();
        }
        return this.set(lo, hi);
      }
      /**
       * Sets the endpoints of this interval to `[∞, -∞]` effectively representing
       * no values
       * @return {Interval} The calling interval
       */
      setEmpty() {
        return this.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
      }
      /**
       * Sets the endpoints of this interval to `[-∞, ∞]` effectively representing all
       * the possible real values
       * @return {Interval} The calling interval
       */
      setWhole() {
        return this.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
      }
      /**
       * Sets the endpoints of this interval to the open interval `(lo, hi)`
       *
       * NOTE: `Interval.round.disable` has no effect on this method
       *
       * @example
       * ```typescript
       * // (2, 3)
       * Interval().open(2, 3)  // {lo: 2.0000000000000004, hi: 2.9999999999999996}
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval
       */
      open(lo, hi) {
        return this.assign(round_default.safeNext(lo), round_default.safePrev(hi));
      }
      /**
       * Sets the endpoints of this interval to the half open interval `(lo, hi]`
       *
       * NOTE: `Interval.round.disable` has no effect on this method
       *
       * @example
       * ```typescript
       * // (2, 3]
       * Interval().halfOpenLeft(2, 3)  // {lo: 2.0000000000000004, hi: 3}
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval
       */
      halfOpenLeft(lo, hi) {
        return this.assign(round_default.safeNext(lo), hi);
      }
      /**
       * Sets the endpoints of this interval to the half open interval `[lo, hi)`
       *
       * NOTE: `Interval.round.disable` has no effect on this method
       *
       * @example
       * ```typescript
       * // [2, 3)
       * Interval.halfOpenRight(2, 3)     // {lo: 2, hi: 2.9999999999999996}
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval
       */
      halfOpenRight(lo, hi) {
        return this.assign(lo, round_default.safePrev(hi));
      }
      /**
       * Array representation of this interval
       * @return {array}
       */
      toArray() {
        return [this.lo, this.hi];
      }
      /**
       * Creates an interval equal to the calling one
       * @see Interval.clone
       * @name Interval.prototype
       * @example
       * ```typescript
       * var x = Interval(2, 3)
       * x.clone()    // Interval(2, 3)
       * ```
       * @return {Interval}
       */
      clone() {
        return new Interval().set(this.lo, this.hi);
      }
    };
    Interval = bindNew(_Interval);
    Interval.factory = Interval;
  }
});

// node_modules/interval-arithmetic/lib-esm/constants.js
var piLow, piHigh, constants, constants_default;
var init_constants = __esm({
  "node_modules/interval-arithmetic/lib-esm/constants.js"() {
    init_interval();
    init_round();
    piLow = (3373259426 + 273688 / (1 << 21)) / (1 << 30);
    piHigh = (3373259426 + 273689 / (1 << 21)) / (1 << 30);
    constants = {
      /**
       * Previous IEEE floating point value of PI (equal to Math.PI)
       * 3.141592653589793
       * @memberof constants
       * @type {number}
       */
      PI_LOW: piLow,
      /**
       * Next IEEE floating point value of PI, 3.1415926535897936
       * @memberof constants
       * @type {number}
       */
      PI_HIGH: piHigh,
      PI_HALF_LOW: piLow / 2,
      PI_HALF_HIGH: piHigh / 2,
      PI_TWICE_LOW: piLow * 2,
      PI_TWICE_HIGH: piHigh * 2,
      /**
       * An interval that represents PI, NOTE: calls to Interval.PI always return
       * a new interval representing PI
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval.E
       * ```
       * @name E
       * @type {Interval}
       */
      get E() {
        return new Interval(round_default.prev(Math.E), round_default.next(Math.E));
      },
      /**
       * An interval that represents Euler's constant e, NOTE: calls to Interval.E always return
       * a new interval representing PI
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval(Interval.PI_LOW, Interval.PI_HIGH)
       * ```
       * @name PI
       * @type {Interval}
       */
      get PI() {
        return new Interval(piLow, piHigh);
      },
      /**
       * An interval that represents `PI / 2`, NOTE: calls to `Interval.PI_HALF` always
       * return a new interval representing `PI / 2`
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval(Interval.PI_LOW / 2, Interval.PI_HIGH / 2)
       * ```
       * @name PI_HALF
       * @type {Interval}
       */
      get PI_HALF() {
        return new Interval(constants.PI_HALF_LOW, constants.PI_HALF_HIGH);
      },
      /**
       * An interval that represents `PI * 2` NOTE: calls to `Interval.PI_TWICE` always
       * return a new interval representing `PI * 2`
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval(Interval.PI_LOW * 2, Interval.PI_HIGH * 2)
       * ```
       * @name PI_TWICE
       * @type {Interval}
       */
      get PI_TWICE() {
        return new Interval(constants.PI_TWICE_LOW, constants.PI_TWICE_HIGH);
      },
      /**
       * An interval that represents 0, NOTE: calls to `Interval.ZERO` always return a new interval representing 0
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * // Interval.ZERO is equivalent to
       * Interval(0)
       * ```
       * @name ZERO
       * @type {Interval}
       */
      get ZERO() {
        return new Interval(0);
      },
      /**
       * An interval that represents 1, NOTE: calls to Interval.ONE always
       * return a new interval representing 1
       * @memberof constants
       * @static
       * @example
       * // Interval.ONE is equivalent to
       * Interval(1)
       * @name ONE
       * @type {Interval}
       */
      get ONE() {
        return new Interval(1);
      },
      /**
       * An interval that represents all the real values
       * NOTE: calls to Interval.WHOLE always return a new interval representing all the real values
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * // Interval.WHOLE is equivalent to
       * Interval().setWhole()
       * ```
       * @name WHOLE
       * @type {Interval}
       */
      get WHOLE() {
        return new Interval().setWhole();
      },
      /**
       * An interval that represents no values
       * NOTE: calls to Interval.EMPTY always return a new interval representing no values
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * // Interval.EMPTY is equivalent to
       * Interval().setEmpty()
       * ```
       * @name EMPTY
       * @type {Interval}
       */
      get EMPTY() {
        return new Interval().setEmpty();
      }
    };
    constants_default = constants;
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/relational.js
var relational_exports = {};
__export(relational_exports, {
  almostEqual: () => almostEqual,
  assertIncludes: () => assertIncludes,
  equal: () => equal,
  geq: () => geq,
  greaterEqualThan: () => greaterEqualThan,
  greaterThan: () => greaterThan,
  gt: () => gt,
  leq: () => leq,
  lessEqualThan: () => lessEqualThan,
  lessThan: () => lessThan,
  lt: () => lt,
  notEqual: () => notEqual
});
function equal(x2, y2) {
  if (isEmpty(x2)) {
    return isEmpty(y2);
  }
  return !isEmpty(y2) && x2.lo === y2.lo && x2.hi === y2.hi;
}
function assert(a2, message) {
  if (!a2) {
    throw new Error(message || "assertion failed");
  }
}
function assertEps(a2, b) {
  if (!isFinite(a2)) {
    return assert(a2 === b, `[Infinity] expected ${a2} to be ${b}`);
  }
  assert(Math.abs(a2 - b) < EPS, `expected ${a2} to be close to ${b}`);
}
function almostEqual(x2, y2) {
  x2 = Array.isArray(x2) ? x2 : x2.toArray();
  y2 = Array.isArray(y2) ? y2 : y2.toArray();
  assertEps(x2[0], y2[0]);
  assertEps(x2[1], y2[1]);
}
function assertIncludes(x2, y2) {
  almostEqual(x2, y2);
  x2 = Array.isArray(x2) ? x2 : x2.toArray();
  y2 = Array.isArray(y2) ? y2 : y2.toArray();
  assert(x2[0] <= y2[0], `${x2[0]} should be less/equal than ${y2[0]}`);
  assert(y2[1] <= x2[1], `${y2[1]} should be less/equal than ${x2[1]}`);
}
function notEqual(x2, y2) {
  if (isEmpty(x2)) {
    return !isEmpty(y2);
  }
  return isEmpty(y2) || x2.hi < y2.lo || x2.lo > y2.hi;
}
function lessThan(x2, y2) {
  if (isEmpty(x2) || isEmpty(y2)) {
    return false;
  }
  return x2.hi < y2.lo;
}
function greaterThan(x2, y2) {
  if (isEmpty(x2) || isEmpty(y2)) {
    return false;
  }
  return x2.lo > y2.hi;
}
function lessEqualThan(x2, y2) {
  if (isEmpty(x2) || isEmpty(y2)) {
    return false;
  }
  return x2.hi <= y2.lo;
}
function greaterEqualThan(x2, y2) {
  if (isEmpty(x2) || isEmpty(y2)) {
    return false;
  }
  return x2.lo >= y2.hi;
}
var EPS, lt, gt, leq, geq;
var init_relational = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/relational.js"() {
    init_utils();
    EPS = 1e-7;
    lt = lessThan;
    gt = greaterThan;
    leq = lessEqualThan;
    geq = greaterEqualThan;
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/division.js
function nonZero(x2, y2) {
  const xl = x2.lo;
  const xh = x2.hi;
  const yl = y2.lo;
  const yh = y2.hi;
  const out = new Interval();
  if (xh < 0) {
    if (yh < 0) {
      out.lo = round_default.divLo(xh, yl);
      out.hi = round_default.divHi(xl, yh);
    } else {
      out.lo = round_default.divLo(xl, yl);
      out.hi = round_default.divHi(xh, yh);
    }
  } else if (xl < 0) {
    if (yh < 0) {
      out.lo = round_default.divLo(xh, yh);
      out.hi = round_default.divHi(xl, yh);
    } else {
      out.lo = round_default.divLo(xl, yl);
      out.hi = round_default.divHi(xh, yl);
    }
  } else {
    if (yh < 0) {
      out.lo = round_default.divLo(xh, yh);
      out.hi = round_default.divHi(xl, yl);
    } else {
      out.lo = round_default.divLo(xl, yh);
      out.hi = round_default.divHi(xh, yl);
    }
  }
  return out;
}
function positive(x2, v) {
  if (x2.lo === 0 && x2.hi === 0) {
    return x2;
  }
  if (zeroIn(x2)) {
    return constants_default.WHOLE;
  }
  if (x2.hi < 0) {
    return new Interval(Number.NEGATIVE_INFINITY, round_default.divHi(x2.hi, v));
  } else {
    return new Interval(round_default.divLo(x2.lo, v), Number.POSITIVE_INFINITY);
  }
}
function negative(x2, v) {
  if (x2.lo === 0 && x2.hi === 0) {
    return x2;
  }
  if (zeroIn(x2)) {
    return constants_default.WHOLE;
  }
  if (x2.hi < 0) {
    return new Interval(round_default.divLo(x2.hi, v), Number.POSITIVE_INFINITY);
  } else {
    return new Interval(Number.NEGATIVE_INFINITY, round_default.divHi(x2.lo, v));
  }
}
function zero(x2) {
  if (x2.lo === 0 && x2.hi === 0) {
    return x2;
  }
  return constants_default.WHOLE;
}
var init_division = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/division.js"() {
    init_interval();
    init_round();
    init_utils();
    init_constants();
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/arithmetic.js
var arithmetic_exports = {};
__export(arithmetic_exports, {
  add: () => add,
  div: () => div,
  divide: () => divide,
  mul: () => mul,
  multiply: () => multiply,
  negative: () => negative2,
  positive: () => positive2,
  sub: () => sub,
  subtract: () => subtract
});
function add(x2, y2) {
  return new Interval(round_default.addLo(x2.lo, y2.lo), round_default.addHi(x2.hi, y2.hi));
}
function subtract(x2, y2) {
  return new Interval(round_default.subLo(x2.lo, y2.hi), round_default.subHi(x2.hi, y2.lo));
}
function multiply(x2, y2) {
  if (isEmpty(x2) || isEmpty(y2)) {
    return constants_default.EMPTY;
  }
  const xl = x2.lo;
  const xh = x2.hi;
  const yl = y2.lo;
  const yh = y2.hi;
  const out = new Interval();
  if (xl < 0) {
    if (xh > 0) {
      if (yl < 0) {
        if (yh > 0) {
          out.lo = Math.min(round_default.mulLo(xl, yh), round_default.mulLo(xh, yl));
          out.hi = Math.max(round_default.mulHi(xl, yl), round_default.mulHi(xh, yh));
        } else {
          out.lo = round_default.mulLo(xh, yl);
          out.hi = round_default.mulHi(xl, yl);
        }
      } else {
        if (yh > 0) {
          out.lo = round_default.mulLo(xl, yh);
          out.hi = round_default.mulHi(xh, yh);
        } else {
          out.lo = 0;
          out.hi = 0;
        }
      }
    } else {
      if (yl < 0) {
        if (yh > 0) {
          out.lo = round_default.mulLo(xl, yh);
          out.hi = round_default.mulHi(xl, yl);
        } else {
          out.lo = round_default.mulLo(xh, yh);
          out.hi = round_default.mulHi(xl, yl);
        }
      } else {
        if (yh > 0) {
          out.lo = round_default.mulLo(xl, yh);
          out.hi = round_default.mulHi(xh, yl);
        } else {
          out.lo = 0;
          out.hi = 0;
        }
      }
    }
  } else {
    if (xh > 0) {
      if (yl < 0) {
        if (yh > 0) {
          out.lo = round_default.mulLo(xh, yl);
          out.hi = round_default.mulHi(xh, yh);
        } else {
          out.lo = round_default.mulLo(xh, yl);
          out.hi = round_default.mulHi(xl, yh);
        }
      } else {
        if (yh > 0) {
          out.lo = round_default.mulLo(xl, yl);
          out.hi = round_default.mulHi(xh, yh);
        } else {
          out.lo = 0;
          out.hi = 0;
        }
      }
    } else {
      out.lo = 0;
      out.hi = 0;
    }
  }
  return out;
}
function divide(x2, y2) {
  if (isEmpty(x2) || isEmpty(y2)) {
    return constants_default.EMPTY;
  }
  if (zeroIn(y2)) {
    if (y2.lo !== 0) {
      if (y2.hi !== 0) {
        return zero(x2);
      } else {
        return negative(x2, y2.lo);
      }
    } else {
      if (y2.hi !== 0) {
        return positive(x2, y2.hi);
      } else {
        return constants_default.EMPTY;
      }
    }
  } else {
    return nonZero(x2, y2);
  }
}
function positive2(x2) {
  return new Interval(x2.lo, x2.hi);
}
function negative2(x2) {
  return new Interval(-x2.hi, -x2.lo);
}
var sub, mul, div;
var init_arithmetic = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/arithmetic.js"() {
    init_interval();
    init_round();
    init_constants();
    init_utils();
    init_division();
    sub = subtract;
    mul = multiply;
    div = divide;
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/algebra.js
var algebra_exports = {};
__export(algebra_exports, {
  fmod: () => fmod,
  multiplicativeInverse: () => multiplicativeInverse,
  nthRoot: () => nthRoot,
  pow: () => pow,
  sqrt: () => sqrt2
});
function fmod(x2, y2) {
  if (isEmpty(x2) || isEmpty(y2)) {
    return constants_default.EMPTY;
  }
  const yb = x2.lo < 0 ? y2.lo : y2.hi;
  let n = x2.lo / yb;
  if (n < 0)
    n = Math.ceil(n);
  else
    n = Math.floor(n);
  return sub(x2, mul(y2, new Interval(n)));
}
function multiplicativeInverse(x2) {
  if (isEmpty(x2)) {
    return constants_default.EMPTY;
  }
  if (zeroIn(x2)) {
    if (x2.lo !== 0) {
      if (x2.hi !== 0) {
        return constants_default.WHOLE;
      } else {
        return new Interval(Number.NEGATIVE_INFINITY, round_default.divHi(1, x2.lo));
      }
    } else {
      if (x2.hi !== 0) {
        return new Interval(round_default.divLo(1, x2.hi), Number.POSITIVE_INFINITY);
      } else {
        return constants_default.EMPTY;
      }
    }
  } else {
    return new Interval(round_default.divLo(1, x2.hi), round_default.divHi(1, x2.lo));
  }
}
function pow(x2, power) {
  if (isEmpty(x2)) {
    return constants_default.EMPTY;
  }
  if (typeof power === "object") {
    if (!isSingleton(power)) {
      return constants_default.EMPTY;
    }
    power = power.lo;
  }
  if (power === 0) {
    if (x2.lo === 0 && x2.hi === 0) {
      return constants_default.EMPTY;
    } else {
      return constants_default.ONE;
    }
  } else if (power < 0) {
    return pow(multiplicativeInverse(x2), -power);
  }
  if (Number.isSafeInteger(power)) {
    if (x2.hi < 0) {
      const yl = round_default.powLo(-x2.hi, power);
      const yh = round_default.powHi(-x2.lo, power);
      if ((power & 1) === 1) {
        return new Interval(-yh, -yl);
      } else {
        return new Interval(yl, yh);
      }
    } else if (x2.lo < 0) {
      if ((power & 1) === 1) {
        return new Interval(-round_default.powLo(-x2.lo, power), round_default.powHi(x2.hi, power));
      } else {
        return new Interval(0, round_default.powHi(Math.max(-x2.lo, x2.hi), power));
      }
    } else {
      return new Interval(round_default.powLo(x2.lo, power), round_default.powHi(x2.hi, power));
    }
  } else {
    console.warn("power is not an integer, you should use nth-root instead, returning an empty interval");
    return constants_default.EMPTY;
  }
}
function sqrt2(x2) {
  return nthRoot(x2, 2);
}
function nthRoot(x2, n) {
  if (isEmpty(x2) || n < 0) {
    return constants_default.EMPTY;
  }
  if (typeof n === "object") {
    if (!isSingleton(n)) {
      return constants_default.EMPTY;
    }
    n = n.lo;
  }
  const power = 1 / n;
  if (x2.hi < 0) {
    if (Number.isSafeInteger(n) && (n & 1) === 1) {
      const yl = round_default.powHi(-x2.lo, power);
      const yh = round_default.powLo(-x2.hi, power);
      return new Interval(-yl, -yh);
    }
    return constants_default.EMPTY;
  } else if (x2.lo < 0) {
    const yp = round_default.powHi(x2.hi, power);
    if (Number.isSafeInteger(n) && (n & 1) === 1) {
      const yn = -round_default.powHi(-x2.lo, power);
      return new Interval(yn, yp);
    }
    return new Interval(0, yp);
  } else {
    return new Interval(round_default.powLo(x2.lo, power), round_default.powHi(x2.hi, power));
  }
}
var init_algebra = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/algebra.js"() {
    init_interval();
    init_round();
    init_constants();
    init_utils();
    init_arithmetic();
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/misc.js
var misc_exports = {};
__export(misc_exports, {
  LOG_EXP_10: () => LOG_EXP_10,
  LOG_EXP_2: () => LOG_EXP_2,
  abs: () => abs2,
  clone: () => clone,
  difference: () => difference,
  exp: () => exp,
  hull: () => hull,
  intersection: () => intersection,
  ln: () => ln,
  log: () => log,
  log10: () => log10,
  log2: () => log2,
  max: () => max2,
  min: () => min2,
  union: () => union,
  wid: () => wid,
  width: () => width
});
function exp(x2) {
  if (isEmpty(x2)) {
    return constants_default.EMPTY;
  }
  return new Interval(round_default.expLo(x2.lo), round_default.expHi(x2.hi));
}
function log(x2) {
  if (isEmpty(x2)) {
    return constants_default.EMPTY;
  }
  const l = x2.lo <= 0 ? Number.NEGATIVE_INFINITY : round_default.logLo(x2.lo);
  return new Interval(l, round_default.logHi(x2.hi));
}
function log10(x2) {
  if (isEmpty(x2)) {
    return constants_default.EMPTY;
  }
  return div(log(x2), LOG_EXP_10);
}
function log2(x2) {
  if (isEmpty(x2)) {
    return constants_default.EMPTY;
  }
  return div(log(x2), LOG_EXP_2);
}
function hull(x2, y2) {
  const badX = isEmpty(x2);
  const badY = isEmpty(y2);
  if (badX && badY) {
    return constants_default.EMPTY;
  } else if (badX) {
    return y2.clone();
  } else if (badY) {
    return x2.clone();
  } else {
    return new Interval(Math.min(x2.lo, y2.lo), Math.max(x2.hi, y2.hi));
  }
}
function intersection(x2, y2) {
  if (isEmpty(x2) || isEmpty(y2)) {
    return constants_default.EMPTY;
  }
  const lo = Math.max(x2.lo, y2.lo);
  const hi = Math.min(x2.hi, y2.hi);
  if (lo <= hi) {
    return new Interval(lo, hi);
  }
  return constants_default.EMPTY;
}
function union(x2, y2) {
  if (!intervalsOverlap(x2, y2)) {
    throw Error("Interval#union: intervals do not overlap");
  }
  return new Interval(Math.min(x2.lo, y2.lo), Math.max(x2.hi, y2.hi));
}
function difference(x2, y2) {
  if (isEmpty(x2) || isWhole(y2)) {
    return constants_default.EMPTY;
  }
  if (intervalsOverlap(x2, y2)) {
    if (x2.lo < y2.lo && y2.hi < x2.hi) {
      throw Error("Interval.difference: difference creates multiple intervals");
    }
    if (y2.lo <= x2.lo && y2.hi === Infinity || y2.hi >= x2.hi && y2.lo === -Infinity) {
      return constants_default.EMPTY;
    }
    if (y2.lo <= x2.lo) {
      return new Interval().halfOpenLeft(y2.hi, x2.hi);
    }
    return new Interval().halfOpenRight(x2.lo, y2.lo);
  }
  return x2.clone();
}
function width(x2) {
  if (isEmpty(x2)) {
    return 0;
  }
  return round_default.subHi(x2.hi, x2.lo);
}
function abs2(x2) {
  if (isEmpty(x2) || isWhole(x2)) {
    return constants_default.EMPTY;
  }
  if (x2.lo >= 0) {
    return x2.clone();
  }
  if (x2.hi <= 0) {
    return negative2(x2);
  }
  return new Interval(0, Math.max(-x2.lo, x2.hi));
}
function max2(x2, y2) {
  const badX = isEmpty(x2);
  const badY = isEmpty(y2);
  if (badX && badY) {
    return constants_default.EMPTY;
  } else if (badX) {
    return y2.clone();
  } else if (badY) {
    return x2.clone();
  } else {
    return new Interval(Math.max(x2.lo, y2.lo), Math.max(x2.hi, y2.hi));
  }
}
function min2(x2, y2) {
  const badX = isEmpty(x2);
  const badY = isEmpty(y2);
  if (badX && badY) {
    return constants_default.EMPTY;
  } else if (badX) {
    return y2.clone();
  } else if (badY) {
    return x2.clone();
  } else {
    return new Interval(Math.min(x2.lo, y2.lo), Math.min(x2.hi, y2.hi));
  }
}
function clone(x2) {
  return new Interval().set(x2.lo, x2.hi);
}
var ln, LOG_EXP_10, LOG_EXP_2, wid;
var init_misc = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/misc.js"() {
    init_interval();
    init_round();
    init_constants();
    init_utils();
    init_arithmetic();
    ln = log;
    LOG_EXP_10 = log(new Interval(10, 10));
    LOG_EXP_2 = log(new Interval(2, 2));
    wid = width;
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/trigonometric.js
var trigonometric_exports = {};
__export(trigonometric_exports, {
  acos: () => acos2,
  asin: () => asin2,
  atan: () => atan,
  cos: () => cos2,
  cosh: () => cosh,
  sin: () => sin2,
  sinh: () => sinh,
  tan: () => tan,
  tanh: () => tanh
});
function onlyInfinity(x2) {
  return !isFinite(x2.lo) && x2.lo === x2.hi;
}
function handleNegative(interval) {
  if (interval.lo < 0) {
    if (interval.lo === -Infinity) {
      interval.lo = 0;
      interval.hi = Infinity;
    } else {
      const n = Math.ceil(-interval.lo / constants_default.PI_TWICE_LOW);
      interval.lo += constants_default.PI_TWICE_LOW * n;
      interval.hi += constants_default.PI_TWICE_LOW * n;
    }
  }
  return interval;
}
function cos2(x2) {
  if (isEmpty(x2) || onlyInfinity(x2)) {
    return constants_default.EMPTY;
  }
  const cache2 = new Interval().set(x2.lo, x2.hi);
  handleNegative(cache2);
  const pi22 = constants_default.PI_TWICE;
  const t = fmod(cache2, pi22);
  if (width(t) >= pi22.lo) {
    return new Interval(-1, 1);
  }
  if (t.lo >= constants_default.PI_HIGH) {
    const cosv = cos2(sub(t, constants_default.PI));
    return negative2(cosv);
  }
  const lo = t.lo;
  const hi = t.hi;
  const rlo = round_default.cosLo(hi);
  const rhi = round_default.cosHi(lo);
  if (hi <= constants_default.PI_LOW) {
    return new Interval(rlo, rhi);
  } else if (hi <= pi22.lo) {
    return new Interval(-1, Math.max(rlo, rhi));
  } else {
    return new Interval(-1, 1);
  }
}
function sin2(x2) {
  if (isEmpty(x2) || onlyInfinity(x2)) {
    return constants_default.EMPTY;
  }
  return cos2(sub(x2, constants_default.PI_HALF));
}
function tan(x2) {
  if (isEmpty(x2) || onlyInfinity(x2)) {
    return constants_default.EMPTY;
  }
  const cache2 = new Interval().set(x2.lo, x2.hi);
  handleNegative(cache2);
  const pi3 = constants_default.PI;
  let t = fmod(cache2, pi3);
  if (t.lo >= constants_default.PI_HALF_LOW) {
    t = sub(t, pi3);
  }
  if (t.lo <= -constants_default.PI_HALF_LOW || t.hi >= constants_default.PI_HALF_LOW) {
    return constants_default.WHOLE;
  }
  return new Interval(round_default.tanLo(t.lo), round_default.tanHi(t.hi));
}
function asin2(x2) {
  if (isEmpty(x2) || x2.hi < -1 || x2.lo > 1) {
    return constants_default.EMPTY;
  }
  const lo = x2.lo <= -1 ? -constants_default.PI_HALF_HIGH : round_default.asinLo(x2.lo);
  const hi = x2.hi >= 1 ? constants_default.PI_HALF_HIGH : round_default.asinHi(x2.hi);
  return new Interval(lo, hi);
}
function acos2(x2) {
  if (isEmpty(x2) || x2.hi < -1 || x2.lo > 1) {
    return constants_default.EMPTY;
  }
  const lo = x2.hi >= 1 ? 0 : round_default.acosLo(x2.hi);
  const hi = x2.lo <= -1 ? constants_default.PI_HIGH : round_default.acosHi(x2.lo);
  return new Interval(lo, hi);
}
function atan(x2) {
  if (isEmpty(x2)) {
    return constants_default.EMPTY;
  }
  return new Interval(round_default.atanLo(x2.lo), round_default.atanHi(x2.hi));
}
function sinh(x2) {
  if (isEmpty(x2)) {
    return constants_default.EMPTY;
  }
  return new Interval(round_default.sinhLo(x2.lo), round_default.sinhHi(x2.hi));
}
function cosh(x2) {
  if (isEmpty(x2)) {
    return constants_default.EMPTY;
  }
  if (x2.hi < 0) {
    return new Interval(round_default.coshLo(x2.hi), round_default.coshHi(x2.lo));
  } else if (x2.lo >= 0) {
    return new Interval(round_default.coshLo(x2.lo), round_default.coshHi(x2.hi));
  } else {
    return new Interval(1, round_default.coshHi(-x2.lo > x2.hi ? x2.lo : x2.hi));
  }
}
function tanh(x2) {
  if (isEmpty(x2)) {
    return constants_default.EMPTY;
  }
  return new Interval(round_default.tanhLo(x2.lo), round_default.tanhHi(x2.hi));
}
var init_trigonometric = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/trigonometric.js"() {
    "use strict";
    init_interval();
    init_round();
    init_constants();
    init_utils();
    init_arithmetic();
    init_algebra();
    init_misc();
  }
});

// node_modules/interval-arithmetic/lib-esm/index.js
var lib_esm_exports = {};
__export(lib_esm_exports, {
  Interval: () => _Interval,
  LOG_EXP_10: () => LOG_EXP_10,
  LOG_EXP_2: () => LOG_EXP_2,
  abs: () => abs2,
  acos: () => acos2,
  add: () => add,
  almostEqual: () => almostEqual,
  asin: () => asin2,
  assertIncludes: () => assertIncludes,
  atan: () => atan,
  clone: () => clone,
  constants: () => constants_default,
  cos: () => cos2,
  cosh: () => cosh,
  default: () => lib_esm_default,
  difference: () => difference,
  div: () => div,
  divide: () => divide,
  equal: () => equal,
  exp: () => exp,
  fmod: () => fmod,
  geq: () => geq,
  greaterEqualThan: () => greaterEqualThan,
  greaterThan: () => greaterThan,
  gt: () => gt,
  hasInterval: () => hasInterval,
  hasValue: () => hasValue,
  hull: () => hull,
  intersection: () => intersection,
  intervalsOverlap: () => intervalsOverlap,
  isEmpty: () => isEmpty,
  isInterval: () => isInterval,
  isSingleton: () => isSingleton,
  isWhole: () => isWhole,
  leq: () => leq,
  lessEqualThan: () => lessEqualThan,
  lessThan: () => lessThan,
  ln: () => ln,
  log: () => log,
  log10: () => log10,
  log2: () => log2,
  lt: () => lt,
  max: () => max2,
  min: () => min2,
  mul: () => mul,
  multiplicativeInverse: () => multiplicativeInverse,
  multiply: () => multiply,
  negative: () => negative2,
  notEqual: () => notEqual,
  nthRoot: () => nthRoot,
  positive: () => positive2,
  pow: () => pow,
  round: () => round_default,
  sin: () => sin2,
  sinh: () => sinh,
  sqrt: () => sqrt2,
  sub: () => sub,
  subtract: () => subtract,
  tan: () => tan,
  tanh: () => tanh,
  union: () => union,
  wid: () => wid,
  width: () => width,
  zeroIn: () => zeroIn
});
var MixedInterval, lib_esm_default;
var init_lib_esm = __esm({
  "node_modules/interval-arithmetic/lib-esm/index.js"() {
    init_interval();
    init_round();
    init_constants();
    init_relational();
    init_arithmetic();
    init_algebra();
    init_trigonometric();
    init_misc();
    init_utils();
    init_relational();
    init_arithmetic();
    init_algebra();
    init_trigonometric();
    init_misc();
    init_utils();
    MixedInterval = Object.assign(Interval, constants_default, round_default, misc_exports, utils_exports, relational_exports, arithmetic_exports, algebra_exports, trigonometric_exports, { round: round_default });
    lib_esm_default = MixedInterval;
  }
});

// node_modules/interval-arithmetic-eval/lib/adapter.js
var require_adapter = __commonJS({
  "node_modules/interval-arithmetic-eval/lib/adapter.js"(exports, module) {
    "use strict";
    module.exports = function(ns) {
      ns.mod = ns.fmod;
      ns.lessThan = ns.lt;
      ns.lessEqualThan = ns.leq;
      ns.greaterThan = ns.gt;
      ns.greaterEqualThan = ns.geq;
      ns.strictlyEqual = ns.equal;
      ns.strictlyNotEqual = ns.notEqual;
      ns.logicalAND = function(a2, b) {
        return a2 && b;
      };
      ns.logicalXOR = function(a2, b) {
        return a2 ^ b;
      };
      ns.logicalOR = function(a2, b) {
        return a2 || b;
      };
    };
  }
});

// node_modules/interval-arithmetic-eval/lib/policies.js
var require_policies = __commonJS({
  "node_modules/interval-arithmetic-eval/lib/policies.js"(exports, module) {
    "use strict";
    module.exports = function(Interval2) {
      return {
        disableRounding: function() {
          Interval2.round.disable();
        },
        enableRounding: function() {
          Interval2.round.enable();
        }
      };
    };
  }
});

// node_modules/interval-arithmetic-eval/lib/eval.js
var require_eval = __commonJS({
  "node_modules/interval-arithmetic-eval/lib/eval.js"(exports, module) {
    "use strict";
    var CodeGenerator = require_math_codegen();
    var Interval2 = (init_lib_esm(), __toCommonJS(lib_esm_exports)).default;
    require_adapter()(Interval2);
    function processScope(scope) {
      Object.keys(scope).forEach(function(k2) {
        const value = scope[k2];
        if (typeof value === "number" || Array.isArray(value)) {
          scope[k2] = Interval2.factory(value);
        } else if (typeof value === "object" && "lo" in value && "hi" in value) {
          scope[k2] = Interval2.factory(value.lo, value.hi);
        }
      });
    }
    module.exports = function(expression) {
      return new CodeGenerator().setDefs({
        $$processScope: processScope
      }).parse(expression).compile(Interval2);
    };
    module.exports.policies = require_policies()(Interval2);
    module.exports.Interval = Interval2;
  }
});

// node_modules/interval-arithmetic-eval/index.js
var require_interval_arithmetic_eval = __commonJS({
  "node_modules/interval-arithmetic-eval/index.js"(exports, module) {
    "use strict";
    module.exports = require_eval();
  }
});

// node_modules/math-codegen/lib/node/ArrayNode.js
var require_ArrayNode3 = __commonJS({
  "node_modules/math-codegen/lib/node/ArrayNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var self = this;
      var arr = [];
      this.rawify(this.options.rawArrayExpressionElements, function() {
        arr = node.nodes.map(function(el) {
          return self.next(el);
        });
      });
      var arrString = "[" + arr.join(",") + "]";
      if (this.options.raw) {
        return arrString;
      }
      return this.options.factory + "(" + arrString + ")";
    };
  }
});

// node_modules/math-codegen/lib/node/AssignmentNode.js
var require_AssignmentNode3 = __commonJS({
  "node_modules/math-codegen/lib/node/AssignmentNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      return 'scope["' + node.name + '"] = ' + this.next(node.expr);
    };
  }
});

// node_modules/math-codegen/lib/node/ConditionalNode.js
var require_ConditionalNode3 = __commonJS({
  "node_modules/math-codegen/lib/node/ConditionalNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var condition = "!!(" + this.next(node.condition) + ")";
      var trueExpr = this.next(node.trueExpr);
      var falseExpr = this.next(node.falseExpr);
      return "(" + condition + " ? (" + trueExpr + ") : (" + falseExpr + ") )";
    };
  }
});

// node_modules/math-codegen/lib/node/ConstantNode.js
var require_ConstantNode3 = __commonJS({
  "node_modules/math-codegen/lib/node/ConstantNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      if (this.options.raw) {
        return node.value;
      }
      return this.options.factory + "(" + node.value + ")";
    };
  }
});

// node_modules/math-codegen/lib/node/FunctionNode.js
var require_FunctionNode3 = __commonJS({
  "node_modules/math-codegen/lib/node/FunctionNode.js"(exports, module) {
    "use strict";
    var SymbolNode = require_mr_parser().nodeTypes.SymbolNode;
    var functionProxy = function(node) {
      return "$$mathCodegen.functionProxy(" + this.next(new SymbolNode(node.name)) + ', "' + node.name + '")';
    };
    module.exports = function(node) {
      var self = this;
      var method = functionProxy.call(this, node);
      var args = [];
      this.rawify(this.options.rawCallExpressionElements, function() {
        args = node.args.map(function(arg) {
          return self.next(arg);
        });
      });
      return method + "(" + args.join(", ") + ")";
    };
    module.exports.functionProxy = functionProxy;
  }
});

// node_modules/math-codegen/lib/misc/Operators.js
var require_Operators2 = __commonJS({
  "node_modules/math-codegen/lib/misc/Operators.js"(exports, module) {
    "use strict";
    module.exports = {
      // arithmetic
      "+": "add",
      "-": "sub",
      "*": "mul",
      "/": "div",
      "^": "pow",
      "%": "mod",
      "!": "factorial",
      // misc operators
      "|": "bitwiseOR",
      // bitwise or
      "^|": "bitwiseXOR",
      // bitwise xor
      "&": "bitwiseAND",
      // bitwise and
      "||": "logicalOR",
      // logical or
      "xor": "logicalXOR",
      // logical xor
      "&&": "logicalAND",
      // logical and
      // comparison
      "<": "lessThan",
      ">": "greaterThan",
      "<=": "lessEqualThan",
      ">=": "greaterEqualThan",
      "===": "strictlyEqual",
      "==": "equal",
      "!==": "strictlyNotEqual",
      "!=": "notEqual",
      // shift
      ">>": "shiftRight",
      "<<": "shiftLeft",
      ">>>": "unsignedRightShift"
    };
  }
});

// node_modules/math-codegen/lib/node/OperatorNode.js
var require_OperatorNode3 = __commonJS({
  "node_modules/math-codegen/lib/node/OperatorNode.js"(exports, module) {
    "use strict";
    var Operators = require_Operators2();
    module.exports = function(node) {
      if (this.options.raw) {
        return ["(" + this.next(node.args[0]), node.op, this.next(node.args[1]) + ")"].join(" ");
      }
      var namedOperator = Operators[node.op];
      if (!namedOperator) {
        throw TypeError("unidentified operator");
      }
      return this.FunctionNode({
        name: namedOperator,
        args: node.args
      });
    };
  }
});

// node_modules/math-codegen/lib/node/SymbolNode.js
var require_SymbolNode3 = __commonJS({
  "node_modules/math-codegen/lib/node/SymbolNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var id = node.name;
      return '$$mathCodegen.getProperty("' + id + '", scope, ns)';
    };
  }
});

// node_modules/math-codegen/lib/misc/UnaryOperators.js
var require_UnaryOperators2 = __commonJS({
  "node_modules/math-codegen/lib/misc/UnaryOperators.js"(exports, module) {
    "use strict";
    module.exports = {
      "+": "positive",
      "-": "negative",
      "~": "oneComplement"
    };
  }
});

// node_modules/math-codegen/lib/node/UnaryNode.js
var require_UnaryNode3 = __commonJS({
  "node_modules/math-codegen/lib/node/UnaryNode.js"(exports, module) {
    "use strict";
    var UnaryOperators = require_UnaryOperators2();
    module.exports = function(node) {
      if (this.options.raw) {
        return node.op + this.next(node.argument);
      }
      if (!(node.op in UnaryOperators)) {
        throw new SyntaxError(node.op + " not implemented");
      }
      var namedOperator = UnaryOperators[node.op];
      return this.FunctionNode({
        name: namedOperator,
        args: [node.argument]
      });
    };
  }
});

// node_modules/math-codegen/lib/Interpreter.js
var require_Interpreter2 = __commonJS({
  "node_modules/math-codegen/lib/Interpreter.js"(exports, module) {
    "use strict";
    var extend2 = require_extend();
    var types = {
      ArrayNode: require_ArrayNode3(),
      AssignmentNode: require_AssignmentNode3(),
      ConditionalNode: require_ConditionalNode3(),
      ConstantNode: require_ConstantNode3(),
      FunctionNode: require_FunctionNode3(),
      OperatorNode: require_OperatorNode3(),
      SymbolNode: require_SymbolNode3(),
      UnaryNode: require_UnaryNode3()
    };
    var Interpreter = function(owner, options) {
      this.owner = owner;
      this.options = extend2({
        factory: "ns.factory",
        raw: false,
        rawArrayExpressionElements: true,
        rawCallExpressionElements: false
      }, options);
    };
    extend2(Interpreter.prototype, types);
    Interpreter.prototype.next = function(node) {
      if (!(node.type in this)) {
        throw new TypeError("the node type " + node.type + " is not implemented");
      }
      return this[node.type](node);
    };
    Interpreter.prototype.rawify = function(test, fn) {
      var oldRaw = this.options.raw;
      if (test) {
        this.options.raw = true;
      }
      fn();
      if (test) {
        this.options.raw = oldRaw;
      }
    };
    module.exports = Interpreter;
  }
});

// node_modules/math-codegen/lib/CodeGenerator.js
var require_CodeGenerator2 = __commonJS({
  "node_modules/math-codegen/lib/CodeGenerator.js"(exports, module) {
    "use strict";
    var Parser = require_mr_parser().Parser;
    var Interpreter = require_Interpreter2();
    var extend2 = require_extend();
    function CodeGenerator(options, defs) {
      this.statements = [];
      this.defs = defs || {};
      this.interpreter = new Interpreter(this, options);
    }
    CodeGenerator.prototype.setDefs = function(defs) {
      this.defs = extend2(this.defs, defs);
      return this;
    };
    CodeGenerator.prototype.compile = function(namespace) {
      if (!namespace || !(typeof namespace === "object" || typeof namespace === "function")) {
        throw TypeError("namespace must be an object");
      }
      if (typeof namespace.factory !== "function") {
        throw TypeError("namespace.factory must be a function");
      }
      this.defs.ns = namespace;
      this.defs.$$mathCodegen = {
        getProperty: function(symbol, scope, ns) {
          if (symbol in scope) {
            return scope[symbol];
          }
          if (symbol in ns) {
            return ns[symbol];
          }
          throw SyntaxError('symbol "' + symbol + '" is undefined');
        },
        functionProxy: function(fn, name) {
          if (typeof fn !== "function") {
            throw SyntaxError('symbol "' + name + '" must be a function');
          }
          return fn;
        }
      };
      this.defs.$$processScope = this.defs.$$processScope || function() {
      };
      var defsCode = Object.keys(this.defs).map(function(name) {
        return "var " + name + ' = defs["' + name + '"]';
      });
      if (!this.statements.length) {
        throw Error("there are no statements saved in this generator, make sure you parse an expression before compiling it");
      }
      this.statements[this.statements.length - 1] = "return " + this.statements[this.statements.length - 1];
      var code = this.statements.join(";");
      var factoryCode = defsCode.join("\n") + "\n" + [
        "return {",
        "  eval: function (scope) {",
        "    scope = scope || {}",
        "    $$processScope(scope)",
        "    " + code,
        "  },",
        "  code: '" + code + "'",
        "}"
      ].join("\n");
      var factory = new Function("defs", factoryCode);
      return factory(this.defs);
    };
    CodeGenerator.prototype.parse = function(code) {
      var self = this;
      var program = new Parser().parse(code);
      this.statements = program.blocks.map(function(statement) {
        return self.interpreter.next(statement);
      });
      return this;
    };
    module.exports = CodeGenerator;
  }
});

// node_modules/math-codegen/index.js
var require_math_codegen2 = __commonJS({
  "node_modules/math-codegen/index.js"(exports, module) {
    "use strict";
    module.exports = require_CodeGenerator2();
  }
});

// node_modules/built-in-math-eval/lib/adapter.js
var require_adapter2 = __commonJS({
  "node_modules/built-in-math-eval/lib/adapter.js"(exports, module) {
    "use strict";
    module.exports = function() {
      var math = Object.create(Math);
      math.factory = function(a2) {
        if (typeof a2 !== "number") {
          throw new TypeError("built-in math factory only accepts numbers");
        }
        return Number(a2);
      };
      math.add = function(a2, b) {
        return a2 + b;
      };
      math.sub = function(a2, b) {
        return a2 - b;
      };
      math.mul = function(a2, b) {
        return a2 * b;
      };
      math.div = function(a2, b) {
        return a2 / b;
      };
      math.mod = function(a2, b) {
        return a2 % b;
      };
      math.factorial = function(a2) {
        var res = 1;
        for (var i = 2; i <= a2; i += 1) {
          res *= i;
        }
        return res;
      };
      math.nthRoot = function(a2, root2) {
        var inv = root2 < 0;
        if (inv) {
          root2 = -root2;
        }
        if (root2 === 0) {
          throw new Error("Root must be non-zero");
        }
        if (a2 < 0 && Math.abs(root2) % 2 !== 1) {
          throw new Error("Root must be odd when a is negative.");
        }
        if (a2 === 0) {
          return 0;
        }
        if (!isFinite(a2)) {
          return inv ? 0 : a2;
        }
        var x2 = Math.pow(Math.abs(a2), 1 / root2);
        x2 = a2 < 0 ? -x2 : x2;
        return inv ? 1 / x2 : x2;
      };
      math.logicalOR = function(a2, b) {
        return a2 || b;
      };
      math.logicalXOR = function(a2, b) {
        return a2 != b;
      };
      math.logicalAND = function(a2, b) {
        return a2 && b;
      };
      math.bitwiseOR = function(a2, b) {
        return a2 | b;
      };
      math.bitwiseXOR = function(a2, b) {
        return a2 ^ b;
      };
      math.bitwiseAND = function(a2, b) {
        return a2 & b;
      };
      math.lessThan = function(a2, b) {
        return a2 < b;
      };
      math.lessEqualThan = function(a2, b) {
        return a2 <= b;
      };
      math.greaterThan = function(a2, b) {
        return a2 > b;
      };
      math.greaterEqualThan = function(a2, b) {
        return a2 >= b;
      };
      math.equal = function(a2, b) {
        return a2 == b;
      };
      math.strictlyEqual = function(a2, b) {
        return a2 === b;
      };
      math.notEqual = function(a2, b) {
        return a2 != b;
      };
      math.strictlyNotEqual = function(a2, b) {
        return a2 !== b;
      };
      math.shiftRight = function(a2, b) {
        return a2 >> b;
      };
      math.shiftLeft = function(a2, b) {
        return a2 << b;
      };
      math.unsignedRightShift = function(a2, b) {
        return a2 >>> b;
      };
      math.negative = function(a2) {
        return -a2;
      };
      math.positive = function(a2) {
        return a2;
      };
      return math;
    };
  }
});

// node_modules/built-in-math-eval/lib/eval.js
var require_eval2 = __commonJS({
  "node_modules/built-in-math-eval/lib/eval.js"(exports, module) {
    "use strict";
    var CodeGenerator = require_math_codegen2();
    var math = require_adapter2()();
    function processScope(scope) {
      Object.keys(scope).forEach(function(k2) {
        var value = scope[k2];
        scope[k2] = math.factory(value);
      });
    }
    module.exports = function(expression) {
      return new CodeGenerator().setDefs({
        $$processScope: processScope
      }).parse(expression).compile(math);
    };
    module.exports.math = math;
  }
});

// node_modules/built-in-math-eval/index.js
var require_built_in_math_eval = __commonJS({
  "node_modules/built-in-math-eval/index.js"(exports, module) {
    "use strict";
    module.exports = require_eval2();
  }
});

// node_modules/function-plot/dist/helpers/eval.js
var require_eval3 = __commonJS({
  "node_modules/function-plot/dist/helpers/eval.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = exports.builtIn = void 0;
    var built_in_math_eval_1 = __importDefault(require_built_in_math_eval());
    var interval_arithmetic_eval_1 = __importDefault(require_interval_arithmetic_eval());
    var samplers = {
      interval: interval_arithmetic_eval_1.default,
      builtIn: built_in_math_eval_1.default
    };
    function getMathJS() {
      if (typeof global === "object" && "math" in global) {
        return global.math;
      }
      if (typeof window === "object" && "math" in window) {
        return window.math;
      }
      return null;
    }
    var mathJS = getMathJS();
    if (mathJS) {
      samplers.builtIn = mathJS.compile;
    }
    function generateEvaluator(samplerName) {
      function doCompile(expression) {
        if (typeof expression === "string") {
          const compiled = samplers[samplerName](expression);
          if (mathJS && samplerName === "builtIn") {
            return { eval: compiled.evaluate || compiled.eval };
          }
          return compiled;
        } else if (typeof expression === "function") {
          return { eval: expression };
        } else {
          throw Error("expression must be a string or a function");
        }
      }
      function compileIfPossible(meta, property) {
        const expression = meta[property];
        const hiddenProperty = samplerName + "_Expression_" + property;
        const hiddenCompiled = samplerName + "_Compiled_" + property;
        if (expression !== meta[hiddenProperty]) {
          meta[hiddenProperty] = expression;
          meta[hiddenCompiled] = doCompile(expression);
        }
      }
      function getCompiledExpression(meta, property) {
        return meta[samplerName + "_Compiled_" + property];
      }
      function evaluate(meta, property, variables) {
        compileIfPossible(meta, property);
        return getCompiledExpression(meta, property).eval(Object.assign({}, meta.scope || {}, variables));
      }
      return evaluate;
    }
    var builtIn = generateEvaluator("builtIn");
    exports.builtIn = builtIn;
    var interval = generateEvaluator("interval");
    exports.interval = interval;
  }
});

// node_modules/function-plot/dist/samplers/interval.js
var require_interval = __commonJS({
  "node_modules/function-plot/dist/samplers/interval.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var interval_arithmetic_eval_1 = __importStar(require_interval_arithmetic_eval());
    var eval_1 = require_eval3();
    var utils_1 = __importDefault(require_utils());
    interval_arithmetic_eval_1.default.policies.disableRounding();
    function interval1d(samplerParams) {
      const xCoords = utils_1.default.space(samplerParams.xAxis, samplerParams.range, samplerParams.nSamples);
      const xScale = samplerParams.xScale;
      const yScale = samplerParams.yScale;
      const yMin = yScale.domain()[0];
      const yMax = yScale.domain()[1];
      const samples = [];
      let i;
      for (i = 0; i < xCoords.length - 1; i += 1) {
        const x2 = { lo: xCoords[i], hi: xCoords[i + 1] };
        const y2 = (0, eval_1.interval)(samplerParams.d, "fn", { x: x2 });
        if (!interval_arithmetic_eval_1.Interval.isEmpty(y2) && !interval_arithmetic_eval_1.Interval.isWhole(y2)) {
          samples.push([x2, y2]);
        }
        if (interval_arithmetic_eval_1.Interval.isWhole(y2)) {
          samples.push(null);
        }
      }
      for (i = 1; i < samples.length - 1; i += 1) {
        if (!samples[i]) {
          const prev2 = samples[i - 1];
          const next2 = samples[i + 1];
          if (prev2 && next2 && !interval_arithmetic_eval_1.Interval.intervalsOverlap(prev2[1], next2[1])) {
            if (prev2[1].lo > next2[1].hi) {
              prev2[1].hi = Math.max(yMax, prev2[1].hi);
              next2[1].lo = Math.min(yMin, next2[1].lo);
            }
            if (prev2[1].hi < next2[1].lo) {
              prev2[1].lo = Math.min(yMin, prev2[1].lo);
              next2[1].hi = Math.max(yMax, next2[1].hi);
            }
          }
        }
      }
      ;
      samples.scaledDx = xScale(xCoords[1]) - xScale(xCoords[0]);
      return [samples];
    }
    var rectEps;
    function smallRect(x2, y2) {
      return interval_arithmetic_eval_1.Interval.width(x2) < rectEps;
    }
    function quadTree(x2, y2, d) {
      const sample = (0, eval_1.interval)(d, "fn", { x: x2, y: y2 });
      const fulfills = interval_arithmetic_eval_1.Interval.zeroIn(sample);
      if (!fulfills) {
        return this;
      }
      if (smallRect(x2, y2)) {
        this.push([x2, y2]);
        return this;
      }
      const midX = x2.lo + (x2.hi - x2.lo) / 2;
      const midY = y2.lo + (y2.hi - y2.lo) / 2;
      const east = { lo: midX, hi: x2.hi };
      const west = { lo: x2.lo, hi: midX };
      const north = { lo: midY, hi: y2.hi };
      const south = { lo: y2.lo, hi: midY };
      quadTree.call(this, east, north, d);
      quadTree.call(this, east, south, d);
      quadTree.call(this, west, north, d);
      quadTree.call(this, west, south, d);
    }
    function interval2d(samplerParams) {
      const xScale = samplerParams.xScale;
      const xDomain = samplerParams.xScale.domain();
      const yDomain = samplerParams.yScale.domain();
      const x2 = { lo: xDomain[0], hi: xDomain[1] };
      const y2 = { lo: yDomain[0], hi: yDomain[1] };
      const samples = [];
      rectEps = xScale.invert(1) - xScale.invert(0);
      quadTree.call(samples, x2, y2, samplerParams.d);
      samples.scaledDx = 1;
      return [samples];
    }
    var sampler = function sampler2(samplerParams) {
      const fnTypes = {
        implicit: interval2d,
        linear: interval1d
      };
      if (!Object.hasOwn(fnTypes, samplerParams.d.fnType)) {
        throw Error(samplerParams.d.fnType + " is not supported in the `interval` sampler");
      }
      return fnTypes[samplerParams.d.fnType].apply(null, arguments);
    };
    exports.default = sampler;
  }
});

// node_modules/function-plot/dist/samplers/builtIn.js
var require_builtIn = __commonJS({
  "node_modules/function-plot/dist/samplers/builtIn.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = __importDefault(require_utils());
    var eval_1 = require_eval3();
    function checkAsymptote(d0, d1, d, sign2, level) {
      if (!level) {
        return { asymptote: true, d0, d1 };
      }
      const n = 10;
      const x0 = d0[0];
      const x1 = d1[0];
      const samples = utils_1.default.linspace(x0, x1, n);
      let oldY, oldX;
      for (let i = 0; i < n; i += 1) {
        const x2 = samples[i];
        const y2 = (0, eval_1.builtIn)(d, "fn", { x: x2 });
        if (oldY) {
          const deltaY = y2 - oldY;
          const newSign = utils_1.default.sgn(deltaY);
          if (newSign === sign2) {
            return checkAsymptote([oldX, oldY], [x2, y2], d, sign2, level - 1);
          }
        }
        oldY = y2;
        oldX = x2;
      }
      return { asymptote: false, d0, d1 };
    }
    function split(d, data, yScale) {
      let oldSign;
      const evalResult = [];
      const yMin = yScale.domain()[0] - utils_1.default.infinity();
      const yMax = yScale.domain()[1] + utils_1.default.infinity();
      let evalGroup = [data[0]];
      let i = 1;
      let deltaX = utils_1.default.infinity();
      while (i < data.length) {
        const yOld = data[i - 1][1];
        const yNew = data[i][1];
        const deltaY = yNew - yOld;
        const newSign = utils_1.default.sgn(deltaY);
        if (
          // we have at least 2 entries (so that we can compute deltaY)
          evalGroup.length >= 2 && // utils.sgn(y1) * utils.sgn(y0) < 0 && // there's a change in the evaluated values sign
          // there's a change in the slope sign
          oldSign !== newSign && // the slope is bigger to some value (according to the current zoom scale)
          Math.abs(deltaY / deltaX) > 1
        ) {
          const check = checkAsymptote(data[i - 1], data[i], d, newSign, 3);
          if (check.asymptote) {
            data[i - 1][0] = check.d0[0];
            data[i - 1][1] = utils_1.default.clamp(check.d0[1], yMin, yMax);
            evalResult.push(evalGroup);
            data[i][0] = check.d1[0];
            data[i][1] = utils_1.default.clamp(check.d1[1], yMin, yMax);
            evalGroup = [data[i]];
          } else {
            evalGroup.push(data[i]);
          }
        } else {
          evalGroup.push(data[i]);
        }
        if (evalGroup.length > 1) {
          deltaX = evalGroup[evalGroup.length - 1][0] - evalGroup[evalGroup.length - 2][0];
          oldSign = newSign;
        }
        ++i;
      }
      if (evalGroup.length) {
        evalResult.push(evalGroup);
      }
      return evalResult;
    }
    function linear(samplerParams) {
      const allX = utils_1.default.space(samplerParams.xAxis, samplerParams.range, samplerParams.nSamples);
      const yDomain = samplerParams.yScale.domain();
      const yMin = yDomain[0] - utils_1.default.infinity();
      const yMax = yDomain[1] + utils_1.default.infinity();
      const data = [];
      for (let i = 0; i < allX.length; i += 1) {
        const x2 = allX[i];
        let y2 = (0, eval_1.builtIn)(samplerParams.d, "fn", { x: x2 });
        if (utils_1.default.isValidNumber(x2) && utils_1.default.isValidNumber(y2)) {
          y2 = utils_1.default.clamp(y2, yMin, yMax);
          data.push([x2, y2]);
        }
      }
      const splitData = split(samplerParams.d, data, samplerParams.yScale);
      return splitData;
    }
    function parametric(samplerParams) {
      const parametricRange = samplerParams.d.range || [0, 2 * Math.PI];
      const tCoords = utils_1.default.space(samplerParams.xAxis, parametricRange, samplerParams.nSamples);
      const samples = [];
      for (let i = 0; i < tCoords.length; i += 1) {
        const t = tCoords[i];
        const x2 = (0, eval_1.builtIn)(samplerParams.d, "x", { t });
        const y2 = (0, eval_1.builtIn)(samplerParams.d, "y", { t });
        samples.push([x2, y2]);
      }
      return [samples];
    }
    function polar(samplerParams) {
      const polarRange = samplerParams.d.range || [-Math.PI, Math.PI];
      const thetaSamples = utils_1.default.space(samplerParams.xAxis, polarRange, samplerParams.nSamples);
      const samples = [];
      for (let i = 0; i < thetaSamples.length; i += 1) {
        const theta = thetaSamples[i];
        const r = (0, eval_1.builtIn)(samplerParams.d, "r", { theta });
        const x2 = r * Math.cos(theta);
        const y2 = r * Math.sin(theta);
        samples.push([x2, y2]);
      }
      return [samples];
    }
    function points(samplerParams) {
      return [samplerParams.d.points];
    }
    function vector(sampleParams) {
      const d = sampleParams.d;
      d.offset = d.offset || [0, 0];
      return [[d.offset, [d.vector[0] + d.offset[0], d.vector[1] + d.offset[1]]]];
    }
    var sampler = function sampler2(samplerParams) {
      const fnTypes = {
        parametric,
        polar,
        points,
        vector,
        linear
      };
      if (!(samplerParams.d.fnType in fnTypes)) {
        throw Error(samplerParams.d.fnType + " is not supported in the `builtIn` sampler");
      }
      return fnTypes[samplerParams.d.fnType].apply(null, arguments);
    };
    exports.default = sampler;
  }
});

// node_modules/function-plot/dist/evaluate.js
var require_evaluate = __commonJS({
  "node_modules/function-plot/dist/evaluate.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals_1 = __importDefault(require_globals());
    var interval_1 = __importDefault(require_interval());
    var builtIn_1 = __importDefault(require_builtIn());
    function computeEndpoints(scale, d) {
      const range = d.range || [-Infinity, Infinity];
      const start = Math.max(scale.domain()[0], range[0]);
      const end = Math.min(scale.domain()[1], range[1]);
      return [start, end];
    }
    function evaluate(chart, d) {
      const range = computeEndpoints(chart.meta.xScale, d);
      let samplerFn;
      if (d.sampler === "builtIn") {
        samplerFn = builtIn_1.default;
      } else if (d.sampler === "interval") {
        samplerFn = interval_1.default;
      } else {
        throw new Error(`Invalid sampler function ${d.sampler}`);
      }
      const nSamples = d.nSamples || Math.min(globals_1.default.MAX_ITERATIONS, globals_1.default.DEFAULT_ITERATIONS || chart.meta.width * 2);
      const data = samplerFn({
        d,
        range,
        xScale: chart.meta.xScale,
        yScale: chart.meta.yScale,
        xAxis: chart.options.xAxis,
        yAxis: chart.options.yAxis,
        nSamples
      });
      chart.emit("eval", data, d.index, d.isHelper);
      return data;
    }
    exports.default = evaluate;
  }
});

// node_modules/function-plot/dist/graph-types/polyline.js
var require_polyline = __commonJS({
  "node_modules/function-plot/dist/graph-types/polyline.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src(), __toCommonJS(src_exports));
    var d3_shape_1 = (init_src3(), __toCommonJS(src_exports2));
    var utils_1 = __importDefault(require_utils());
    var evaluate_1 = __importDefault(require_evaluate());
    function polyline(chart) {
      function plotLine(selection2) {
        selection2.each(function(d) {
          const el = plotLine.el = (0, d3_selection_1.select)(this);
          const index = d.index;
          const evaluatedData = (0, evaluate_1.default)(chart, d);
          const color2 = utils_1.default.color(d, index);
          const innerSelection = el.selectAll(":scope > path.line").data(evaluatedData);
          const yRange = chart.meta.yScale.range();
          let yMax = yRange[0];
          let yMin = yRange[1];
          const diff = yMax - yMin;
          yMax += diff * 1e6;
          yMin -= diff * 1e6;
          if (d.skipBoundsCheck) {
            yMax = utils_1.default.infinity();
            yMin = -utils_1.default.infinity();
          }
          function y2(d2) {
            return utils_1.default.clamp(chart.meta.yScale(d2[1]), yMin, yMax);
          }
          const line = (0, d3_shape_1.line)().curve(d3_shape_1.curveLinear).x(function(d2) {
            return chart.meta.xScale(d2[0]);
          }).y(y2);
          const area = (0, d3_shape_1.area)().x(function(d2) {
            return chart.meta.xScale(d2[0]);
          }).y0(chart.meta.yScale(0)).y1(y2);
          const cls = `line line-${index}`;
          const innerSelectionEnter = innerSelection.enter().append("path").attr("class", cls).attr("stroke-width", 1).attr("stroke-linecap", "round");
          innerSelection.merge(innerSelectionEnter).each(function() {
            const path2 = (0, d3_selection_1.select)(this);
            let pathD;
            if (d.closed) {
              path2.attr("fill", color2);
              path2.attr("fill-opacity", 0.3);
              pathD = area;
            } else {
              path2.attr("fill", "none");
              pathD = line;
            }
            path2.attr("stroke", color2).attr("marker-end", function() {
              return d.fnType === "vector" ? "url(#" + chart.markerId + ")" : null;
            }).attr("d", pathD);
            if (d.attr) {
              for (const k2 in d.attr) {
                let val = d.attr[k2];
                if (k2 === "class") {
                  val = `${cls} ${d.attr[k2]}`;
                }
                path2.attr(k2, val);
              }
            }
          });
          innerSelection.exit().remove();
        });
      }
      return plotLine;
    }
    exports.default = polyline;
  }
});

// node_modules/function-plot/dist/graph-types/interval.js
var require_interval2 = __commonJS({
  "node_modules/function-plot/dist/graph-types/interval.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src(), __toCommonJS(src_exports));
    var evaluate_1 = __importDefault(require_evaluate());
    var utils_1 = __importDefault(require_utils());
    function interval(chart) {
      let minWidthHeight;
      const xScale = chart.meta.xScale;
      const yScale = chart.meta.yScale;
      function clampRange(vLo, vHi, gLo, gHi) {
        if (gLo > gHi) {
          const t = gLo;
          gLo = gHi;
          gHi = t;
        }
        const hi = Math.min(vHi, gHi);
        const lo = Math.max(vLo, gLo);
        if (lo > hi) {
          return [-minWidthHeight, 0];
        }
        return [lo, hi];
      }
      const line = function(points, closed) {
        let path2 = "";
        const range = yScale.range();
        const minY = Math.min.apply(Math, range);
        const maxY = Math.max.apply(Math, range);
        for (let i = 0, length = points.length; i < length; i += 1) {
          if (points[i]) {
            const x2 = points[i][0];
            const y2 = points[i][1];
            let yLo = y2.lo;
            let yHi = y2.hi;
            if (closed) {
              yLo = Math.min(yLo, 0);
              yHi = Math.max(yHi, 0);
            }
            const moveX = xScale(x2.lo) + points.scaledDx / 2;
            const viewportY = clampRange(minY, maxY, isFinite(yHi) ? yScale(yHi) : -Infinity, isFinite(yLo) ? yScale(yLo) : Infinity);
            const vLo = viewportY[0];
            const vHi = viewportY[1];
            path2 += " M " + moveX + " " + vLo;
            path2 += " v " + Math.max(vHi - vLo, minWidthHeight);
          }
        }
        return path2;
      };
      function plotLine(selection2) {
        selection2.each(function(d) {
          const el = plotLine.el = (0, d3_selection_1.select)(this);
          const index = d.index;
          const closed = d.closed;
          const evaluatedData = (0, evaluate_1.default)(chart, d);
          const innerSelection = el.selectAll(":scope > path.line").data(evaluatedData);
          minWidthHeight = Math.max(evaluatedData[0].scaledDx, 1);
          const cls = `line line-${index}`;
          const innerSelectionEnter = innerSelection.enter().append("path").attr("class", cls).attr("fill", "none");
          const selection3 = innerSelection.merge(innerSelectionEnter).attr("stroke-width", minWidthHeight).attr("stroke", utils_1.default.color(d, index)).attr("opacity", closed ? 0.5 : 1).attr("d", function(d2) {
            return line(d2, closed);
          });
          if (d.attr) {
            for (const k2 in d.attr) {
              let val = d.attr[k2];
              if (k2 === "class") {
                val = `${cls} ${d.attr[k2]}`;
              }
              selection3.attr(k2, val);
            }
          }
          innerSelection.exit().remove();
        });
      }
      return plotLine;
    }
    exports.default = interval;
  }
});

// node_modules/function-plot/dist/graph-types/scatter.js
var require_scatter = __commonJS({
  "node_modules/function-plot/dist/graph-types/scatter.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src(), __toCommonJS(src_exports));
    var d3_color_1 = (init_src4(), __toCommonJS(src_exports3));
    var utils_1 = __importDefault(require_utils());
    var evaluate_1 = __importDefault(require_evaluate());
    function Scatter(chart) {
      const xScale = chart.meta.xScale;
      const yScale = chart.meta.yScale;
      function scatter(selection2) {
        selection2.each(function(d) {
          let i, j;
          const index = d.index;
          const color2 = utils_1.default.color(d, index);
          const evaluatedData = (0, evaluate_1.default)(chart, d);
          const joined = [];
          for (i = 0; i < evaluatedData.length; i += 1) {
            for (j = 0; j < evaluatedData[i].length; j += 1) {
              joined.push(evaluatedData[i][j]);
            }
          }
          const innerSelection = (0, d3_selection_1.select)(this).selectAll(":scope > circle.scatter").data(joined);
          const cls = `scatter scatter-${index}`;
          const innerSelectionEnter = innerSelection.enter().append("circle").attr("class", cls);
          const selection3 = innerSelection.merge(innerSelectionEnter).attr("fill", (0, d3_color_1.hsl)(color2.toString()).brighter(1.5).formatHex()).attr("stroke", color2).attr("opacity", 0.7).attr("r", 1).attr("cx", function(d2) {
            return xScale(d2[0]);
          }).attr("cy", function(d2) {
            return yScale(d2[1]);
          });
          if (d.attr) {
            for (const k2 in d.attr) {
              let val = d.attr[k2];
              if (k2 === "class") {
                val = `${cls} ${d.attr[k2]}`;
              }
              selection3.attr(k2, val);
            }
          }
          innerSelection.exit().remove();
        });
      }
      return scatter;
    }
    exports.default = Scatter;
  }
});

// node_modules/function-plot/dist/graph-types/text.js
var require_text = __commonJS({
  "node_modules/function-plot/dist/graph-types/text.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src(), __toCommonJS(src_exports));
    var d3_color_1 = (init_src4(), __toCommonJS(src_exports3));
    var utils_1 = __importDefault(require_utils());
    function Text(chart) {
      const xScale = chart.meta.xScale;
      const yScale = chart.meta.yScale;
      function text(selection2) {
        selection2.each(function(d) {
          d.sampler = "builtIn";
          d.fnType = "vector";
          const innerSelection = (0, d3_selection_1.select)(this).selectAll(":scope > text.fn-text").data([d.location]);
          const innerSelectionEnter = innerSelection.enter().append("text").attr("class", `fn-text fn-text-${d.index}`);
          const color2 = utils_1.default.color(d, d.index);
          const selection3 = innerSelection.merge(innerSelectionEnter).attr("fill", (0, d3_color_1.hsl)(color2.toString()).brighter(1.5).formatHex()).attr("x", (d2) => xScale(d2[0])).attr("y", (d2) => yScale(d2[1])).text(() => d.text);
          if (d.attr) {
            for (const k2 in d.attr) {
              selection3.attr(k2, d.attr[k2]);
            }
          }
          innerSelection.exit().remove();
        });
      }
      return text;
    }
    exports.default = Text;
  }
});

// node_modules/function-plot/dist/graph-types/index.js
var require_graph_types = __commonJS({
  "node_modules/function-plot/dist/graph-types/index.js"(exports) {
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.text = exports.scatter = exports.interval = exports.polyline = void 0;
    var polyline_1 = __importDefault(require_polyline());
    exports.polyline = polyline_1.default;
    var interval_1 = __importDefault(require_interval2());
    exports.interval = interval_1.default;
    var scatter_1 = __importDefault(require_scatter());
    exports.scatter = scatter_1.default;
    var text_1 = __importDefault(require_text());
    exports.text = text_1.default;
  }
});

export {
  src_exports2 as src_exports,
  init_src3 as init_src,
  color,
  rgb,
  hsl,
  lab,
  hcl,
  cubehelix,
  init_src4 as init_src2,
  namespace_default,
  selector_default,
  selectorAll_default,
  matcher_default,
  styleValue,
  selection_default,
  select_default2 as select_default,
  pointer_default,
  src_exports as src_exports2,
  init_src as init_src3,
  require_globals,
  require_utils,
  require_eval3 as require_eval,
  require_graph_types
};
//# sourceMappingURL=chunk-53R4YMQM.js.map
